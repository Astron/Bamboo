/* This file was generated by PyBindGen 0.17.0.871 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#ifndef PyVarObject_HEAD_INIT
#define PyVarObject_HEAD_INIT(type, size) \
        PyObject_HEAD_INIT(type) size,
#endif


#if PY_VERSION_HEX >= 0x03000000
typedef void* cmpfunc;
#define PyCObject_FromVoidPtr(a, b) PyCapsule_New(a, NULL, b)
#define PyCObject_AsVoidPtr(a) PyCapsule_GetPointer(a, NULL)
#define PyString_FromString(a) PyBytes_FromString(a)
#define Py_TPFLAGS_CHECKTYPES 0 /* this flag doesn't exist in python 3 */
#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

#ifndef _PyBindGenWrapperFlags_defined_
#define _PyBindGenWrapperFlags_defined_
typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;
#endif


#include "bits/byteorder.h"
#include "bits/sizetag.h"
#include "bits/Buffer.h"
#include "module/ArrayType.h"
#include "module/Class.h"
#include "module/DistributedType.h"
#include "module/Field.h"
#include "module/KeywordList.h"
#include "module/Method.h"
#include "module/Module.h"
#include "module/MolecularField.h"
#include "module/NumericRange.h"
#include "module/NumericType.h"
#include "module/Parameter.h"
#include "module/Struct.h"
#include "module/TypeData.h"
#include "traits/hashes.h"
#include "dcfile/format.h"
#include "dcfile/parse.h"
#include "dcfile/write.h"
#include "wire/Datagram.h"
#include "wire/DatagramIterator.h"
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    bamboo::Buffer *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooBuffer;


extern PyTypeObject PyBambooBuffer_Type;


extern PyTypeObject *Pystd__out_of_range_Type;

/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    bamboo::Module *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooModule;


extern PyTypeObject PyBambooModule_Type;


typedef struct {
    PyObject_HEAD
    bamboo::DistributedType *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooDistributedType;


extern PyTypeObject PyBambooDistributedType_Type;


typedef struct {
    PyObject_HEAD
    bamboo::NumericType *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooNumericType;


extern PyTypeObject PyBambooNumericType_Type;


typedef struct {
    PyObject_HEAD
    bamboo::ArrayType *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooArrayType;


extern PyTypeObject PyBambooArrayType_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Method *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooMethod;


extern PyTypeObject PyBambooMethod_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Struct *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooStruct;


extern PyTypeObject PyBambooStruct_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Class *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooClass;


extern PyTypeObject PyBambooClass_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Parameter *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooParameter;


extern PyTypeObject PyBambooParameter_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Field *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooField;


extern PyTypeObject PyBambooField_Type;


typedef struct {
    PyObject_HEAD
    bamboo::MolecularField *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooMolecularField;


extern PyTypeObject PyBambooMolecularField_Type;


typedef struct {
    PyObject_HEAD
    bamboo::TypeData *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooTypeData;


extern PyTypeObject PyBambooTypeData_Type;


typedef struct {
    PyObject_HEAD
    bamboo::TypeDataHandle *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooTypeDataHandle;


extern PyTypeObject PyBambooTypeDataHandle_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Import *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooImport;


extern PyTypeObject PyBambooImport_Type;


typedef struct {
    PyObject_HEAD
    bamboo::Number *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooNumber;


extern PyTypeObject PyBambooNumber_Type;


typedef struct {
    PyObject_HEAD
    bamboo::NumericRange *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooNumericRange;


extern PyTypeObject PyBambooNumericRange_Type;


typedef struct {
    PyObject_HEAD
    std::vector<std::string> *obj;
} Pystd__vector__lt__std__string__gt__;


typedef struct {
    PyObject_HEAD
    Pystd__vector__lt__std__string__gt__ *container;
    std::vector<std::string>::iterator *iterator;
} Pystd__vector__lt__std__string__gt__Iter;


extern PyTypeObject Pystd__vector__lt__std__string__gt___Type;
extern PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container);
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    bamboo::Datagram *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooDatagram;


extern PyTypeObject PyBambooDatagram_Type;


typedef struct {
    PyObject_HEAD
    bamboo::DatagramIterator *obj;
    PyBindGenWrapperFlags flags:8;
} PyBambooDatagramIterator;


extern PyTypeObject PyBambooDatagramIterator_Type;


int _wrap_convert_py2c__bamboo__Buffer(PyObject *value, bamboo::Buffer *address);


int _wrap_convert_py2c__std__string(PyObject *value, std::string *address);

static PyMethodDef bamboo_bits_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */




static int
_wrap_PyBambooBuffer__tp_init__0(PyBambooBuffer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Buffer();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooBuffer__tp_init__1(PyBambooBuffer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyBambooBuffer *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Buffer(*((PyBambooBuffer *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooBuffer__tp_init__2(PyBambooBuffer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Buffer();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooBuffer__tp_init__3(PyBambooBuffer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyBambooBuffer *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Buffer(*((PyBambooBuffer *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyBambooBuffer__tp_init(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyBambooBuffer__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooBuffer__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyBambooBuffer__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyBambooBuffer__tp_init__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyBambooBuffer_fromString(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *val;
    Py_ssize_t val_len;
    std::string val_std;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &val, &val_len)) {
        return NULL;
    }
    val_std = std::string(val, val_len);
    bamboo::Buffer retval = bamboo::Buffer::from_string(val_std);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_int64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_int64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packInt8(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7f) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_int8(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packBool(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    self->obj->pack_bool(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_string(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *val;
    Py_ssize_t val_len;
    std::string val_std;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &val, &val_len)) {
        return NULL;
    }
    val_std = std::string(val, val_len);
    bamboo::Buffer retval = bamboo::Buffer::from_string(val_std);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_uint64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint64_t retval;

    retval = self->obj->read_uint64();
    py_retval = Py_BuildValue((char *) "K", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromUint8(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint8(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromUint64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint64_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "K", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packFloat32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    float val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_float32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readBool(PyBambooBuffer *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->read_bool();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packFloat64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_float64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_bool(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    bamboo::Buffer retval = bamboo::Buffer::from_bool(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_float32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    float val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_float32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_uint16(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_uint16(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromInt16(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int16(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_int16(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int16_t retval;

    retval = self->obj->read_int16();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packBuffer(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooBuffer *val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &val)) {
        return NULL;
    }
    self->obj->pack_buffer(*((PyBambooBuffer *) val)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packUint32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_uint32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_int32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int32_t retval;

    retval = self->obj->read_int32();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_seek(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    self->obj->seek(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readInt8(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int8_t retval;

    retval = self->obj->read_int8();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_size(PyBambooBuffer *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packUint16(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_uint16(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_bool(PyBambooBuffer *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->read_bool();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_int8(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int8_t retval;

    retval = self->obj->read_int8();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_float32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    float val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_float32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readFloat32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    float retval;

    retval = self->obj->read_float32();
    py_retval = Py_BuildValue((char *) "f", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_buffer(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooBuffer *val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &val)) {
        return NULL;
    }
    self->obj->pack_buffer(*((PyBambooBuffer *) val)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_uint64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint64_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "K", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_string(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *val;
    Py_ssize_t val_len;
    std::string val_std;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &val, &val_len)) {
        return NULL;
    }
    val_std = std::string(val, val_len);
    self->obj->pack_string(val_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packChar(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "c", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_char(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readInt64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int64_t retval;

    retval = self->obj->read_int64();
    py_retval = Py_BuildValue((char *) "L", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readUint8(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint8_t retval;

    retval = self->obj->read_uint8();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packString(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *val;
    Py_ssize_t val_len;
    std::string val_std;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &val, &val_len)) {
        return NULL;
    }
    val_std = std::string(val, val_len);
    self->obj->pack_string(val_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_uint64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint64_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "K", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_uint64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packInt64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_int64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_bool(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    self->obj->pack_bool(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_uint8(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_uint8(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_int8(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7f) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int8(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromInt64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packUint8(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_uint8(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_uint32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint32_t retval;

    retval = self->obj->read_uint32();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_tell(PyBambooBuffer *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->tell();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readUint64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint64_t retval;

    retval = self->obj->read_uint64();
    py_retval = Py_BuildValue((char *) "K", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_uint16(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint16_t retval;

    retval = self->obj->read_uint16();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_float64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_float64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_uint32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer___getitem__(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint8_t retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    try
    {
        retval = self->obj->get_byte(index);
    } catch (std::out_of_range const &exc) {
        PyErr_SetString((PyObject *) Pystd__out_of_range_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromInt8(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7f) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int8(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_int32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_int32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer___deepcopy__(PyBambooBuffer *self)
{
    PyObject *py_retval;
    PyBambooBuffer *py_Buffer;

    bamboo::Buffer retval = self->obj->copy();
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_char(PyBambooBuffer *self)
{
    PyObject *py_retval;
    char retval;

    retval = self->obj->read_char();
    py_retval = Py_BuildValue((char *) "c", (int) retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromUint16(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint16(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_int16(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_int16(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readFloat64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->read_float64();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromInt32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromBool(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    bamboo::Buffer retval = bamboo::Buffer::from_bool(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_int64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int64_t retval;

    retval = self->obj->read_int64();
    py_retval = Py_BuildValue((char *) "L", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_uint8(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint8_t retval;

    retval = self->obj->read_uint8();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readChar(PyBambooBuffer *self)
{
    PyObject *py_retval;
    char retval;

    retval = self->obj->read_char();
    py_retval = Py_BuildValue((char *) "c", (int) retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_int16(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int16(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_copy(PyBambooBuffer *self)
{
    PyObject *py_retval;
    PyBambooBuffer *py_Buffer;

    bamboo::Buffer retval = self->obj->copy();
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromChar(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "c", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_char(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_char(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "c", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_char(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_float64(PyBambooBuffer *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->read_float64();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readInt32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int32_t retval;

    retval = self->obj->read_int32();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_uint8(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint8(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer___setitem__(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    char item;
    const char *keywords[] = {"index", "item", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ic", (char **) keywords, &index, &item)) {
        return NULL;
    }
    try
    {
        self->obj->set_byte(index, item);
    } catch (std::out_of_range const &exc) {
        PyErr_SetString((PyObject *) Pystd__out_of_range_Type, exc.what());
        return NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_uint32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_uint32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packUint64(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint64_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "K", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_uint64(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_float64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_float64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readInt16(PyBambooBuffer *self)
{
    PyObject *py_retval;
    int16_t retval;

    retval = self->obj->read_int16();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromFloat64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_float64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_int8(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7f) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_int8(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_int32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_read_float32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    float retval;

    retval = self->obj->read_float32();
    py_retval = Py_BuildValue((char *) "f", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromUint32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_fromFloat32(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    float val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_float32(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_pack_char(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "c", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_char(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readUint32(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint32_t retval;

    retval = self->obj->read_uint32();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packInt16(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->pack_int16(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_packInt32(PyBambooBuffer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t val;
    const char *keywords[] = {"val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    self->obj->pack_int32(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_readUint16(PyBambooBuffer *self)
{
    PyObject *py_retval;
    uint16_t retval;

    retval = self->obj->read_uint16();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_int64(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &val)) {
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_int64(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyBambooBuffer_from_uint16(PyBambooBuffer *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int val;
    const char *keywords[] = {"val", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &val)) {
        return NULL;
    }
    if (val > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    bamboo::Buffer retval = bamboo::Buffer::from_uint16(val);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


static PyObject*
_wrap_PyBambooBuffer__copy__(PyBambooBuffer *self)
{

    PyBambooBuffer *py_copy;
    py_copy = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_copy->obj = new bamboo::Buffer(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyBambooBuffer_methods[] = {
    {(char *) "fromString", (PyCFunction) _wrap_PyBambooBuffer_fromString, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_int64", (PyCFunction) _wrap_PyBambooBuffer_pack_int64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packInt8", (PyCFunction) _wrap_PyBambooBuffer_packInt8, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packBool", (PyCFunction) _wrap_PyBambooBuffer_packBool, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_string", (PyCFunction) _wrap_PyBambooBuffer_from_string, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "read_uint64", (PyCFunction) _wrap_PyBambooBuffer_read_uint64, METH_NOARGS, NULL },
    {(char *) "fromUint8", (PyCFunction) _wrap_PyBambooBuffer_fromUint8, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "fromUint64", (PyCFunction) _wrap_PyBambooBuffer_fromUint64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "packFloat32", (PyCFunction) _wrap_PyBambooBuffer_packFloat32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readBool", (PyCFunction) _wrap_PyBambooBuffer_readBool, METH_NOARGS, NULL },
    {(char *) "packFloat64", (PyCFunction) _wrap_PyBambooBuffer_packFloat64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_bool", (PyCFunction) _wrap_PyBambooBuffer_from_bool, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_float32", (PyCFunction) _wrap_PyBambooBuffer_pack_float32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "pack_uint16", (PyCFunction) _wrap_PyBambooBuffer_pack_uint16, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "fromInt16", (PyCFunction) _wrap_PyBambooBuffer_fromInt16, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "read_int16", (PyCFunction) _wrap_PyBambooBuffer_read_int16, METH_NOARGS, NULL },
    {(char *) "packBuffer", (PyCFunction) _wrap_PyBambooBuffer_packBuffer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packUint32", (PyCFunction) _wrap_PyBambooBuffer_packUint32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "read_int32", (PyCFunction) _wrap_PyBambooBuffer_read_int32, METH_NOARGS, NULL },
    {(char *) "seek", (PyCFunction) _wrap_PyBambooBuffer_seek, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readInt8", (PyCFunction) _wrap_PyBambooBuffer_readInt8, METH_NOARGS, NULL },
    {(char *) "size", (PyCFunction) _wrap_PyBambooBuffer_size, METH_NOARGS, NULL },
    {(char *) "packUint16", (PyCFunction) _wrap_PyBambooBuffer_packUint16, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "read_bool", (PyCFunction) _wrap_PyBambooBuffer_read_bool, METH_NOARGS, NULL },
    {(char *) "read_int8", (PyCFunction) _wrap_PyBambooBuffer_read_int8, METH_NOARGS, NULL },
    {(char *) "from_float32", (PyCFunction) _wrap_PyBambooBuffer_from_float32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "readFloat32", (PyCFunction) _wrap_PyBambooBuffer_readFloat32, METH_NOARGS, NULL },
    {(char *) "pack_buffer", (PyCFunction) _wrap_PyBambooBuffer_pack_buffer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_uint64", (PyCFunction) _wrap_PyBambooBuffer_from_uint64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_string", (PyCFunction) _wrap_PyBambooBuffer_pack_string, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packChar", (PyCFunction) _wrap_PyBambooBuffer_packChar, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readInt64", (PyCFunction) _wrap_PyBambooBuffer_readInt64, METH_NOARGS, NULL },
    {(char *) "readUint8", (PyCFunction) _wrap_PyBambooBuffer_readUint8, METH_NOARGS, NULL },
    {(char *) "packString", (PyCFunction) _wrap_PyBambooBuffer_packString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "pack_uint64", (PyCFunction) _wrap_PyBambooBuffer_pack_uint64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packInt64", (PyCFunction) _wrap_PyBambooBuffer_packInt64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "pack_bool", (PyCFunction) _wrap_PyBambooBuffer_pack_bool, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "pack_uint8", (PyCFunction) _wrap_PyBambooBuffer_pack_uint8, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_int8", (PyCFunction) _wrap_PyBambooBuffer_from_int8, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "fromInt64", (PyCFunction) _wrap_PyBambooBuffer_fromInt64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "packUint8", (PyCFunction) _wrap_PyBambooBuffer_packUint8, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "read_uint32", (PyCFunction) _wrap_PyBambooBuffer_read_uint32, METH_NOARGS, NULL },
    {(char *) "tell", (PyCFunction) _wrap_PyBambooBuffer_tell, METH_NOARGS, NULL },
    {(char *) "readUint64", (PyCFunction) _wrap_PyBambooBuffer_readUint64, METH_NOARGS, NULL },
    {(char *) "read_uint16", (PyCFunction) _wrap_PyBambooBuffer_read_uint16, METH_NOARGS, NULL },
    {(char *) "pack_float64", (PyCFunction) _wrap_PyBambooBuffer_pack_float64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_uint32", (PyCFunction) _wrap_PyBambooBuffer_from_uint32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "fromInt8", (PyCFunction) _wrap_PyBambooBuffer_fromInt8, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_int32", (PyCFunction) _wrap_PyBambooBuffer_pack_int32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__deepcopy__", (PyCFunction) _wrap_PyBambooBuffer___deepcopy__, METH_NOARGS, NULL },
    {(char *) "read_char", (PyCFunction) _wrap_PyBambooBuffer_read_char, METH_NOARGS, NULL },
    {(char *) "fromUint16", (PyCFunction) _wrap_PyBambooBuffer_fromUint16, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_int16", (PyCFunction) _wrap_PyBambooBuffer_pack_int16, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readFloat64", (PyCFunction) _wrap_PyBambooBuffer_readFloat64, METH_NOARGS, NULL },
    {(char *) "fromInt32", (PyCFunction) _wrap_PyBambooBuffer_fromInt32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "fromBool", (PyCFunction) _wrap_PyBambooBuffer_fromBool, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "read_int64", (PyCFunction) _wrap_PyBambooBuffer_read_int64, METH_NOARGS, NULL },
    {(char *) "read_uint8", (PyCFunction) _wrap_PyBambooBuffer_read_uint8, METH_NOARGS, NULL },
    {(char *) "readChar", (PyCFunction) _wrap_PyBambooBuffer_readChar, METH_NOARGS, NULL },
    {(char *) "from_int16", (PyCFunction) _wrap_PyBambooBuffer_from_int16, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "copy", (PyCFunction) _wrap_PyBambooBuffer_copy, METH_NOARGS, NULL },
    {(char *) "fromChar", (PyCFunction) _wrap_PyBambooBuffer_fromChar, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "from_char", (PyCFunction) _wrap_PyBambooBuffer_from_char, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "read_float64", (PyCFunction) _wrap_PyBambooBuffer_read_float64, METH_NOARGS, NULL },
    {(char *) "readInt32", (PyCFunction) _wrap_PyBambooBuffer_readInt32, METH_NOARGS, NULL },
    {(char *) "from_uint8", (PyCFunction) _wrap_PyBambooBuffer_from_uint8, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_uint32", (PyCFunction) _wrap_PyBambooBuffer_pack_uint32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packUint64", (PyCFunction) _wrap_PyBambooBuffer_packUint64, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_float64", (PyCFunction) _wrap_PyBambooBuffer_from_float64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "readInt16", (PyCFunction) _wrap_PyBambooBuffer_readInt16, METH_NOARGS, NULL },
    {(char *) "fromFloat64", (PyCFunction) _wrap_PyBambooBuffer_fromFloat64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_int8", (PyCFunction) _wrap_PyBambooBuffer_pack_int8, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "from_int32", (PyCFunction) _wrap_PyBambooBuffer_from_int32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "read_float32", (PyCFunction) _wrap_PyBambooBuffer_read_float32, METH_NOARGS, NULL },
    {(char *) "fromUint32", (PyCFunction) _wrap_PyBambooBuffer_fromUint32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "fromFloat32", (PyCFunction) _wrap_PyBambooBuffer_fromFloat32, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "pack_char", (PyCFunction) _wrap_PyBambooBuffer_pack_char, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readUint32", (PyCFunction) _wrap_PyBambooBuffer_readUint32, METH_NOARGS, NULL },
    {(char *) "packInt16", (PyCFunction) _wrap_PyBambooBuffer_packInt16, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "packInt32", (PyCFunction) _wrap_PyBambooBuffer_packInt32, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readUint16", (PyCFunction) _wrap_PyBambooBuffer_readUint16, METH_NOARGS, NULL },
    {(char *) "from_int64", (PyCFunction) _wrap_PyBambooBuffer_from_int64, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "from_uint16", (PyCFunction) _wrap_PyBambooBuffer_from_uint16, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyBambooBuffer__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooBuffer__tp_dealloc(PyBambooBuffer *self)
{
        bamboo::Buffer *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooBuffer__tp_richcompare (PyBambooBuffer *PYBINDGEN_UNUSED(self), PyBambooBuffer *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooBuffer_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


int _wrap_convert_py2c__bamboo__Buffer(PyObject *value, bamboo::Buffer *address)
{
    PyObject *py_retval;
    PyBambooBuffer *tmp_Buffer;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyBambooBuffer_Type, &tmp_Buffer)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Buffer->obj;
    Py_DECREF(py_retval);
    return 1;
}


static PyObject*
BambooBuffer__sq_item (PyBambooBuffer *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyBambooBuffer___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
BambooBuffer__sq_ass_item (PyBambooBuffer *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyBambooBuffer___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        PyErr_SetString(PyExc_IndexError, "Unknown error trying to set value in container.");
        return -1;
#if PY_MAJOR_VERSION >= 3
    } else if (PyLong_Check(result) == 0) {
#else
    } else if (PyInt_Check(result) == 0) {
#endif
        PyErr_SetString(PyExc_IndexError, "Error trying to set value in container -- wrapped method should return integer status.");
        return -1;
    } else {
#if PY_MAJOR_VERSION >= 3
        int iresult = int(PyLong_AS_LONG(result));
#else
        int iresult = int(PyInt_AS_LONG(result));
#endif
        Py_DECREF(result);
        return iresult;
    }
}



static PySequenceMethods BambooBuffer__py_sequence_methods = {
    (lenfunc) NULL,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) BambooBuffer__sq_item,
#if PY_MAJOR_VERSION < 3
    (ssizessizeargfunc) NULL,
#else
    NULL,
#endif
    (ssizeobjargproc) BambooBuffer__sq_ass_item,
#if PY_MAJOR_VERSION < 3
    (ssizessizeobjargproc) NULL,
#else
    NULL,
#endif
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyBambooBuffer_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.bits.Buffer",            /* tp_name */
    sizeof(PyBambooBuffer),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooBuffer__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)&BambooBuffer__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooBuffer__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooBuffer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooBuffer__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- exceptions --- */


PyTypeObject *Pystd__out_of_range_Type;

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_bits_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo.bits",
    NULL,
    -1,
    bamboo_bits_functions,
};
#endif

static PyObject *
initbamboo_bits(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_bits_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo.bits", bamboo_bits_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    /* Register the 'bamboo::Buffer' class */
    if (PyType_Ready(&PyBambooBuffer_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Buffer", (PyObject *) &PyBambooBuffer_Type);
    /* Register the 'std::out_of_range' exception */
    if ((Pystd__out_of_range_Type = (PyTypeObject*) PyErr_NewException((char*)"bamboo.bits.IndexError", NULL, NULL)) == NULL) {
        return NULL;
    }
    Py_INCREF((PyObject *) Pystd__out_of_range_Type);
    PyModule_AddObject(m, (char *) "IndexError", (PyObject *) Pystd__out_of_range_Type);
    return m;
}
static PyMethodDef bamboo_module_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */



static int
_wrap_PyBambooModule__tp_init(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new bamboo::Module();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooModule_getClass(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_class(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getStruct(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooStruct *py_Struct;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_struct(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_class(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_class(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_class_by_name(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_class_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_num_types(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_types();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getNumImports(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_imports();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_addKeyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keyword;
    Py_ssize_t keyword_len;
    std::string keyword_std;
    const char *keywords[] = {"keyword", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &keyword, &keyword_len)) {
        return NULL;
    }
    keyword_std = std::string(keyword, keyword_len);
    self->obj->add_keyword(keyword_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getTypeByName(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooDistributedType *py_DistributedType;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_type_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getTypeById(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooDistributedType *py_DistributedType;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_type_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_num_imports(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_imports();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_add_typedef(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"name", "type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->add_typedef(name_std, type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_add_struct(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooStruct *dstruct;
    bamboo::Struct *dstruct_ptr;
    const char *keywords[] = {"dstruct", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooStruct_Type, &dstruct)) {
        return NULL;
    }
    dstruct_ptr = (dstruct ? dstruct->obj : NULL);
    retval = self->obj->add_struct(dstruct_ptr);
    if (dstruct) {
        dstruct->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getImport(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Import *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooImport *py_Import;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_import(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Import = PyObject_New(PyBambooImport, &PyBambooImport_Type);
    py_Import->obj = new bamboo::Import((*retval));
    py_Import->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Import);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getNumStructs(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_structs();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_has_keyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *keyword;
    Py_ssize_t keyword_len;
    std::string keyword_std;
    const char *keywords[] = {"keyword", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &keyword, &keyword_len)) {
        return NULL;
    }
    keyword_std = std::string(keyword, keyword_len);
    retval = self->obj->has_keyword(keyword_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_keyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_keyword(n);
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getNumTypes(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_types();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_field_by_id(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_hasKeyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *keyword;
    Py_ssize_t keyword_len;
    std::string keyword_std;
    const char *keywords[] = {"keyword", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &keyword, &keyword_len)) {
        return NULL;
    }
    keyword_std = std::string(keyword, keyword_len);
    retval = self->obj->has_keyword(keyword_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_type_by_id(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooDistributedType *py_DistributedType;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_type_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_addClass(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooClass *dclass;
    bamboo::Class *dclass_ptr;
    const char *keywords[] = {"dclass", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooClass_Type, &dclass)) {
        return NULL;
    }
    dclass_ptr = (dclass ? dclass->obj : NULL);
    retval = self->obj->add_class(dclass_ptr);
    if (dclass) {
        dclass->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_struct(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooStruct *py_Struct;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_struct(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getClassByName(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_class_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getFieldById(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_type_by_name(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooDistributedType *py_DistributedType;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_type_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getKeyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_keyword(n);
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getNumKeywords(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_keywords();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_num_structs(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_structs();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_import(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Import *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooImport *py_Import;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_import(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Import = PyObject_New(PyBambooImport, &PyBambooImport_Type);
    py_Import->obj = new bamboo::Import((*retval));
    py_Import->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Import);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getClassById(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_class_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_class_by_id(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_class_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_add_keyword(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keyword;
    Py_ssize_t keyword_len;
    std::string keyword_std;
    const char *keywords[] = {"keyword", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &keyword, &keyword_len)) {
        return NULL;
    }
    keyword_std = std::string(keyword, keyword_len);
    self->obj->add_keyword(keyword_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_addStruct(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooStruct *dstruct;
    bamboo::Struct *dstruct_ptr;
    const char *keywords[] = {"dstruct", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooStruct_Type, &dstruct)) {
        return NULL;
    }
    dstruct_ptr = (dstruct ? dstruct->obj : NULL);
    retval = self->obj->add_struct(dstruct_ptr);
    if (dstruct) {
        dstruct->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_add_import(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooImport *import;
    bamboo::Import *import_ptr;
    const char *keywords[] = {"import", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooImport_Type, &import)) {
        return NULL;
    }
    import_ptr = (import ? import->obj : NULL);
    self->obj->add_import(import_ptr);
    if (import) {
        import->obj = NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_addImport(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooImport *import;
    bamboo::Import *import_ptr;
    const char *keywords[] = {"import", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooImport_Type, &import)) {
        return NULL;
    }
    import_ptr = (import ? import->obj : NULL);
    self->obj->add_import(import_ptr);
    if (import) {
        import->obj = NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_getNumClasses(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_classes();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_add_class(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooClass *dclass;
    bamboo::Class *dclass_ptr;
    const char *keywords[] = {"dclass", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooClass_Type, &dclass)) {
        return NULL;
    }
    dclass_ptr = (dclass ? dclass->obj : NULL);
    retval = self->obj->add_class(dclass_ptr);
    if (dclass) {
        dclass->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_num_classes(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_classes();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_addTypedef(PyBambooModule *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"name", "type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->add_typedef(name_std, type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooModule_get_num_keywords(PyBambooModule *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_keywords();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}

static PyMethodDef PyBambooModule_methods[] = {
    {(char *) "getClass", (PyCFunction) _wrap_PyBambooModule_getClass, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th Class in the module." },
    {(char *) "getStruct", (PyCFunction) _wrap_PyBambooModule_getStruct, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th Struct in the module." },
    {(char *) "get_class", (PyCFunction) _wrap_PyBambooModule_get_class, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th Class in the module." },
    {(char *) "get_class_by_name", (PyCFunction) _wrap_PyBambooModule_get_class_by_name, METH_KEYWORDS|METH_VARARGS, "Returns the requested Class or None if there is no such class." },
    {(char *) "get_num_types", (PyCFunction) _wrap_PyBambooModule_get_num_types, METH_NOARGS, "Returns the number of types in the module (classes, structs, typedefs)." },
    {(char *) "getNumImports", (PyCFunction) _wrap_PyBambooModule_getNumImports, METH_NOARGS, "Returns the number of imports in the module." },
    {(char *) "addKeyword", (PyCFunction) _wrap_PyBambooModule_addKeyword, METH_KEYWORDS|METH_VARARGS, "Adds the keyword to the list of keywords accepted by the module." },
    {(char *) "getTypeByName", (PyCFunction) _wrap_PyBambooModule_getTypeByName, METH_KEYWORDS|METH_VARARGS, "Returns the requested DistributedType or None if there is no such type." },
    {(char *) "getTypeById", (PyCFunction) _wrap_PyBambooModule_getTypeById, METH_KEYWORDS|METH_VARARGS, "Returns the requested DistributedType or None if there is no such type." },
    {(char *) "get_num_imports", (PyCFunction) _wrap_PyBambooModule_get_num_imports, METH_NOARGS, "Returns the number of imports in the module." },
    {(char *) "add_typedef", (PyCFunction) _wrap_PyBambooModule_add_typedef, METH_KEYWORDS|METH_VARARGS, "Creates a new alias in the module for a given type." },
    {(char *) "add_struct", (PyCFunction) _wrap_PyBambooModule_add_struct, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Struct to the Module returning false if there is a name conflict." },
    {(char *) "getImport", (PyCFunction) _wrap_PyBambooModule_getImport, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th import in the module." },
    {(char *) "getNumStructs", (PyCFunction) _wrap_PyBambooModule_getNumStructs, METH_NOARGS, "Returns the number of structs in the module." },
    {(char *) "has_keyword", (PyCFunction) _wrap_PyBambooModule_has_keyword, METH_KEYWORDS|METH_VARARGS, "Returns true if a keyword with the name <keyword> is declared in the module." },
    {(char *) "get_keyword", (PyCFunction) _wrap_PyBambooModule_get_keyword, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th keyword declared in the module." },
    {(char *) "getNumTypes", (PyCFunction) _wrap_PyBambooModule_getNumTypes, METH_NOARGS, "Returns the number of types in the module (classes, structs, typedefs)." },
    {(char *) "get_field_by_id", (PyCFunction) _wrap_PyBambooModule_get_field_by_id, METH_KEYWORDS|METH_VARARGS, "Returns the requested Field or None if there is no such type." },
    {(char *) "hasKeyword", (PyCFunction) _wrap_PyBambooModule_hasKeyword, METH_KEYWORDS|METH_VARARGS, "Returns true if a keyword with the name <keyword> is declared in the module." },
    {(char *) "get_type_by_id", (PyCFunction) _wrap_PyBambooModule_get_type_by_id, METH_KEYWORDS|METH_VARARGS, "Returns the requested DistributedType or None if there is no such type." },
    {(char *) "addClass", (PyCFunction) _wrap_PyBambooModule_addClass, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Class to the Module returning false if there is a name conflict." },
    {(char *) "get_struct", (PyCFunction) _wrap_PyBambooModule_get_struct, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th Struct in the module." },
    {(char *) "getClassByName", (PyCFunction) _wrap_PyBambooModule_getClassByName, METH_KEYWORDS|METH_VARARGS, "Returns the requested Class or None if there is no such class." },
    {(char *) "getFieldById", (PyCFunction) _wrap_PyBambooModule_getFieldById, METH_KEYWORDS|METH_VARARGS, "Returns the requested Field or None if there is no such type." },
    {(char *) "get_type_by_name", (PyCFunction) _wrap_PyBambooModule_get_type_by_name, METH_KEYWORDS|METH_VARARGS, "Returns the requested DistributedType or None if there is no such type." },
    {(char *) "getKeyword", (PyCFunction) _wrap_PyBambooModule_getKeyword, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th keyword declared in the module." },
    {(char *) "getNumKeywords", (PyCFunction) _wrap_PyBambooModule_getNumKeywords, METH_NOARGS, "Returns the number of keywords declared in the module." },
    {(char *) "get_num_structs", (PyCFunction) _wrap_PyBambooModule_get_num_structs, METH_NOARGS, "Returns the number of structs in the module." },
    {(char *) "get_import", (PyCFunction) _wrap_PyBambooModule_get_import, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th import in the module." },
    {(char *) "getClassById", (PyCFunction) _wrap_PyBambooModule_getClassById, METH_KEYWORDS|METH_VARARGS, "Returns the requested Class or None if there is no such class." },
    {(char *) "get_class_by_id", (PyCFunction) _wrap_PyBambooModule_get_class_by_id, METH_KEYWORDS|METH_VARARGS, "Returns the requested Class or None if there is no such class." },
    {(char *) "add_keyword", (PyCFunction) _wrap_PyBambooModule_add_keyword, METH_KEYWORDS|METH_VARARGS, "Adds the keyword to the list of keywords accepted by the module." },
    {(char *) "addStruct", (PyCFunction) _wrap_PyBambooModule_addStruct, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Struct to the Module returning false if there is a name conflict." },
    {(char *) "add_import", (PyCFunction) _wrap_PyBambooModule_add_import, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Import to the Module, merging it with any duplicate modules." },
    {(char *) "addImport", (PyCFunction) _wrap_PyBambooModule_addImport, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Import to the Module, merging it with any duplicate modules." },
    {(char *) "getNumClasses", (PyCFunction) _wrap_PyBambooModule_getNumClasses, METH_NOARGS, "Returns the number of classes in the module." },
    {(char *) "add_class", (PyCFunction) _wrap_PyBambooModule_add_class, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Class to the Module returning false if there is a name conflict." },
    {(char *) "get_num_classes", (PyCFunction) _wrap_PyBambooModule_get_num_classes, METH_NOARGS, "Returns the number of classes in the module." },
    {(char *) "addTypedef", (PyCFunction) _wrap_PyBambooModule_addTypedef, METH_KEYWORDS|METH_VARARGS, "Creates a new alias in the module for a given type." },
    {(char *) "get_num_keywords", (PyCFunction) _wrap_PyBambooModule_get_num_keywords, METH_NOARGS, "Returns the number of keywords declared in the module." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooModule__tp_dealloc(PyBambooModule *self)
{
        bamboo::Module *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooModule__tp_richcompare (PyBambooModule *PYBINDGEN_UNUSED(self), PyBambooModule *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooModule_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooModule_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Module",            /* tp_name */
    sizeof(PyBambooModule),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooModule__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "A Module represents the complete list of Distributed Class definitions that define a particular protocol. Typically, parsed from one or more \".dc\" or other bamboo protocol description files.",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooModule__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooModule_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooModule__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





PyObject *
_wrap_PyBambooDistributedType_get_subtype(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Subtype retval;

    retval = self->obj->get_subtype();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_get_size(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_size();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_as_array(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::ArrayType *retval;
    PyBambooArrayType *py_ArrayType;

    retval = self->obj->as_array();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_ArrayType = PyObject_New(PyBambooArrayType, &PyBambooArrayType_Type);
    py_ArrayType->obj = new bamboo::ArrayType((*retval));
    py_ArrayType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_ArrayType);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_asMethod(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->as_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_hasFixedSize(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_fixed_size();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_as_struct(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->as_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_asArray(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::ArrayType *retval;
    PyBambooArrayType *py_ArrayType;

    retval = self->obj->as_array();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_ArrayType = PyObject_New(PyBambooArrayType, &PyBambooArrayType_Type);
    py_ArrayType->obj = new bamboo::ArrayType((*retval));
    py_ArrayType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_ArrayType);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_setAlias(PyBambooDistributedType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *alias;
    Py_ssize_t alias_len;
    std::string alias_std;
    const char *keywords[] = {"alias", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &alias, &alias_len)) {
        return NULL;
    }
    alias_std = std::string(alias, alias_len);
    self->obj->set_alias(alias_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_as_numeric(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::NumericType *retval;
    PyBambooNumericType *py_NumericType;

    retval = self->obj->as_numeric();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_NumericType = PyObject_New(PyBambooNumericType, &PyBambooNumericType_Type);
    py_NumericType->obj = new bamboo::NumericType((*retval));
    py_NumericType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_NumericType);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_getAlias(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_alias();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_getSubtype(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Subtype retval;

    retval = self->obj->get_subtype();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_get_alias(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_alias();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_has_alias(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_alias();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_getSize(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_size();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_has_fixed_size(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_fixed_size();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_as_method(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->as_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_hasAlias(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_alias();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_asNumeric(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::NumericType *retval;
    PyBambooNumericType *py_NumericType;

    retval = self->obj->as_numeric();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_NumericType = PyObject_New(PyBambooNumericType, &PyBambooNumericType_Type);
    py_NumericType->obj = new bamboo::NumericType((*retval));
    py_NumericType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_NumericType);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_asStruct(PyBambooDistributedType *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->as_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}


PyObject *
_wrap_PyBambooDistributedType_set_alias(PyBambooDistributedType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *alias;
    Py_ssize_t alias_len;
    std::string alias_std;
    const char *keywords[] = {"alias", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &alias, &alias_len)) {
        return NULL;
    }
    alias_std = std::string(alias, alias_len);
    self->obj->set_alias(alias_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyBambooDistributedType_methods[] = {
    {(char *) "get_subtype", (PyCFunction) _wrap_PyBambooDistributedType_get_subtype, METH_NOARGS, "Returns the type's fundamental type as an integer constant." },
    {(char *) "get_size", (PyCFunction) _wrap_PyBambooDistributedType_get_size, METH_NOARGS, "Returns the size of the DistributedType in bytes or 0 if it is variable." },
    {(char *) "as_array", (PyCFunction) _wrap_PyBambooDistributedType_as_array, METH_NOARGS, "Returns this as an ArrayType if it is an array, or None otherwise." },
    {(char *) "asMethod", (PyCFunction) _wrap_PyBambooDistributedType_asMethod, METH_NOARGS, "Returns this as a Method if it is a method, or None otherwise." },
    {(char *) "hasFixedSize", (PyCFunction) _wrap_PyBambooDistributedType_hasFixedSize, METH_NOARGS, "Returns true if the DistributedType has a fixed size in bytes." },
    {(char *) "as_struct", (PyCFunction) _wrap_PyBambooDistributedType_as_struct, METH_NOARGS, "Returns this as a Struct if it is a struct, or None otherwise." },
    {(char *) "asArray", (PyCFunction) _wrap_PyBambooDistributedType_asArray, METH_NOARGS, "Returns this as an ArrayType if it is an array, or None otherwise." },
    {(char *) "setAlias", (PyCFunction) _wrap_PyBambooDistributedType_setAlias, METH_KEYWORDS|METH_VARARGS, "Gives this type an alternate name <alias>." },
    {(char *) "as_numeric", (PyCFunction) _wrap_PyBambooDistributedType_as_numeric, METH_NOARGS, "Returns this as a NumericType if it is numeric, or None otherwise." },
    {(char *) "getAlias", (PyCFunction) _wrap_PyBambooDistributedType_getAlias, METH_NOARGS, "Returns the name used to define the type, or the empty string." },
    {(char *) "getSubtype", (PyCFunction) _wrap_PyBambooDistributedType_getSubtype, METH_NOARGS, "Returns the type's fundamental type as an integer constant." },
    {(char *) "get_alias", (PyCFunction) _wrap_PyBambooDistributedType_get_alias, METH_NOARGS, "Returns the name used to define the type, or the empty string." },
    {(char *) "has_alias", (PyCFunction) _wrap_PyBambooDistributedType_has_alias, METH_NOARGS, "Returns true if this type was defined the an aliased name." },
    {(char *) "getSize", (PyCFunction) _wrap_PyBambooDistributedType_getSize, METH_NOARGS, "Returns the size of the DistributedType in bytes or 0 if it is variable." },
    {(char *) "has_fixed_size", (PyCFunction) _wrap_PyBambooDistributedType_has_fixed_size, METH_NOARGS, "Returns true if the DistributedType has a fixed size in bytes." },
    {(char *) "as_method", (PyCFunction) _wrap_PyBambooDistributedType_as_method, METH_NOARGS, "Returns this as a Method if it is a method, or None otherwise." },
    {(char *) "hasAlias", (PyCFunction) _wrap_PyBambooDistributedType_hasAlias, METH_NOARGS, "Returns true if this type was defined the an aliased name." },
    {(char *) "asNumeric", (PyCFunction) _wrap_PyBambooDistributedType_asNumeric, METH_NOARGS, "Returns this as a NumericType if it is numeric, or None otherwise." },
    {(char *) "asStruct", (PyCFunction) _wrap_PyBambooDistributedType_asStruct, METH_NOARGS, "Returns this as a Struct if it is a struct, or None otherwise." },
    {(char *) "set_alias", (PyCFunction) _wrap_PyBambooDistributedType_set_alias, METH_KEYWORDS|METH_VARARGS, "Gives this type an alternate name <alias>." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooDistributedType__tp_dealloc(PyBambooDistributedType *self)
{
        bamboo::DistributedType *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooDistributedType__tp_richcompare (PyBambooDistributedType *PYBINDGEN_UNUSED(self), PyBambooDistributedType *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooDistributedType_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooDistributedType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.DistributedType",            /* tp_name */
    sizeof(PyBambooDistributedType),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooDistributedType__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "A DistributedType represents any bamboo type. DistributedTypes have a defined layout of data.",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooDistributedType__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooDistributedType_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooNumericType__tp_init(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    bamboo::Subtype subtype;
    const char *keywords[] = {"subtype", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &subtype)) {
        return -1;
    }
    self->obj = new bamboo::NumericType(subtype);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooNumericType_get_divisor(PyBambooNumericType *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_divisor();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_set_range(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooNumericRange *range;
    const char *keywords[] = {"range", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooNumericRange_Type, &range)) {
        return NULL;
    }
    retval = self->obj->set_range(*((PyBambooNumericRange *) range)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_getRange(PyBambooNumericType *self)
{
    PyObject *py_retval;
    PyBambooNumericRange *py_NumericRange;

    bamboo::NumericRange retval = self->obj->get_range();
    py_NumericRange = PyObject_New(PyBambooNumericRange, &PyBambooNumericRange_Type);
    py_NumericRange->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NumericRange->obj = new bamboo::NumericRange(retval);
    py_retval = Py_BuildValue((char *) "N", py_NumericRange);
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_has_modulus(PyBambooNumericType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_modulus();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_set_modulus(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    double modulus;
    const char *keywords[] = {"modulus", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &modulus)) {
        return NULL;
    }
    retval = self->obj->set_modulus(modulus);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_hasRange(PyBambooNumericType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_range();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_setDivisor(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int divisor;
    const char *keywords[] = {"divisor", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &divisor)) {
        return NULL;
    }
    retval = self->obj->set_divisor(divisor);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_get_range(PyBambooNumericType *self)
{
    PyObject *py_retval;
    PyBambooNumericRange *py_NumericRange;

    bamboo::NumericRange retval = self->obj->get_range();
    py_NumericRange = PyObject_New(PyBambooNumericRange, &PyBambooNumericRange_Type);
    py_NumericRange->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NumericRange->obj = new bamboo::NumericRange(retval);
    py_retval = Py_BuildValue((char *) "N", py_NumericRange);
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_set_divisor(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int divisor;
    const char *keywords[] = {"divisor", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &divisor)) {
        return NULL;
    }
    retval = self->obj->set_divisor(divisor);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_has_range(PyBambooNumericType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_range();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_setModulus(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    double modulus;
    const char *keywords[] = {"modulus", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &modulus)) {
        return NULL;
    }
    retval = self->obj->set_modulus(modulus);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_get_modulus(PyBambooNumericType *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->get_modulus();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_hasModulus(PyBambooNumericType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_modulus();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_getDivisor(PyBambooNumericType *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_divisor();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_getModulus(PyBambooNumericType *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->get_modulus();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyBambooNumericType_setRange(PyBambooNumericType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooNumericRange *range;
    const char *keywords[] = {"range", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooNumericRange_Type, &range)) {
        return NULL;
    }
    retval = self->obj->set_range(*((PyBambooNumericRange *) range)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyBambooNumericType_methods[] = {
    {(char *) "get_divisor", (PyCFunction) _wrap_PyBambooNumericType_get_divisor, METH_NOARGS, "Retuns the divisior of the numeric, with a default value of one." },
    {(char *) "set_range", (PyCFunction) _wrap_PyBambooNumericType_set_range, METH_KEYWORDS|METH_VARARGS, "Sets a range for the numeric type, typically to represent fixed point.  Returns false if the range is not valid for this type." },
    {(char *) "getRange", (PyCFunction) _wrap_PyBambooNumericType_getRange, METH_NOARGS, "Returns the NumericRange that constrains this type's values." },
    {(char *) "has_modulus", (PyCFunction) _wrap_PyBambooNumericType_has_modulus, METH_NOARGS, "Returns true if the numeric is constrained by a modulus." },
    {(char *) "set_modulus", (PyCFunction) _wrap_PyBambooNumericType_set_modulus, METH_KEYWORDS|METH_VARARGS, "Sets a modulus for the numeric type, typically to represent fixed point.  Returns false if the modulus is not valid for this type." },
    {(char *) "hasRange", (PyCFunction) _wrap_PyBambooNumericType_hasRange, METH_NOARGS, "Returns true if the numeric is constrained by a range." },
    {(char *) "setDivisor", (PyCFunction) _wrap_PyBambooNumericType_setDivisor, METH_KEYWORDS|METH_VARARGS, "Sets a divisor for the numeric type, typically to represent fixed point.  Returns false if the divisor is not valid for this type." },
    {(char *) "get_range", (PyCFunction) _wrap_PyBambooNumericType_get_range, METH_NOARGS, "Returns the NumericRange that constrains this type's values." },
    {(char *) "set_divisor", (PyCFunction) _wrap_PyBambooNumericType_set_divisor, METH_KEYWORDS|METH_VARARGS, "Sets a divisor for the numeric type, typically to represent fixed point.  Returns false if the divisor is not valid for this type." },
    {(char *) "has_range", (PyCFunction) _wrap_PyBambooNumericType_has_range, METH_NOARGS, "Returns true if the numeric is constrained by a range." },
    {(char *) "setModulus", (PyCFunction) _wrap_PyBambooNumericType_setModulus, METH_KEYWORDS|METH_VARARGS, "Sets a modulus for the numeric type, typically to represent fixed point.  Returns false if the modulus is not valid for this type." },
    {(char *) "get_modulus", (PyCFunction) _wrap_PyBambooNumericType_get_modulus, METH_NOARGS, "Returns a double precision floating-point representation of the modulus value." },
    {(char *) "hasModulus", (PyCFunction) _wrap_PyBambooNumericType_hasModulus, METH_NOARGS, "Returns true if the numeric is constrained by a modulus." },
    {(char *) "getDivisor", (PyCFunction) _wrap_PyBambooNumericType_getDivisor, METH_NOARGS, "Retuns the divisior of the numeric, with a default value of one." },
    {(char *) "getModulus", (PyCFunction) _wrap_PyBambooNumericType_getModulus, METH_NOARGS, "Returns a double precision floating-point representation of the modulus value." },
    {(char *) "setRange", (PyCFunction) _wrap_PyBambooNumericType_setRange, METH_KEYWORDS|METH_VARARGS, "Sets a range for the numeric type, typically to represent fixed point.  Returns false if the range is not valid for this type." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooNumericType__tp_dealloc(PyBambooNumericType *self)
{
        bamboo::NumericType *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooNumericType__tp_richcompare (PyBambooNumericType *PYBINDGEN_UNUSED(self), PyBambooNumericType *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooNumericType_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooNumericType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.NumericType",            /* tp_name */
    sizeof(PyBambooNumericType),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooNumericType__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "A NumericType can represent any of the basic number types (ie. integers, floats, etc).  A NumericType may also have a range and/or modulus to limit its possible values, and/or a divisor representing a fixed-point numeric convention.  A divisor scales up any range or modulus to constrain up to (constraint * divisor).",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooNumericType__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooNumericType_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooNumericType__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooArrayType__tp_init(PyBambooArrayType *self, PyObject *args, PyObject *kwargs)
{
    PyBambooDistributedType *elementType;
    bamboo::DistributedType *elementType_ptr;
    PyBambooNumericRange *arraySize = NULL;
    const char *keywords[] = {"elementType", "arraySize", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|O!", (char **) keywords, &PyBambooDistributedType_Type, &elementType, &PyBambooNumericRange_Type, &arraySize)) {
        return -1;
    }
    elementType_ptr = (elementType ? elementType->obj : NULL);
    self->obj = new bamboo::ArrayType(elementType_ptr, (arraySize ? (*((PyBambooNumericRange *) arraySize)->obj) : bamboo::NumericRange()));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooArrayType_getRange(PyBambooArrayType *self)
{
    PyObject *py_retval;
    PyBambooNumericRange *py_NumericRange;

    bamboo::NumericRange retval = self->obj->get_range();
    py_NumericRange = PyObject_New(PyBambooNumericRange, &PyBambooNumericRange_Type);
    py_NumericRange->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NumericRange->obj = new bamboo::NumericRange(retval);
    py_retval = Py_BuildValue((char *) "N", py_NumericRange);
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_get_array_size(PyBambooArrayType *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_array_size();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_hasRange(PyBambooArrayType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_range();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_getArraySize(PyBambooArrayType *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_array_size();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_getElementType(PyBambooArrayType *self)
{
    PyObject *py_retval;
    bamboo::DistributedType const *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_element_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_get_range(PyBambooArrayType *self)
{
    PyObject *py_retval;
    PyBambooNumericRange *py_NumericRange;

    bamboo::NumericRange retval = self->obj->get_range();
    py_NumericRange = PyObject_New(PyBambooNumericRange, &PyBambooNumericRange_Type);
    py_NumericRange->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NumericRange->obj = new bamboo::NumericRange(retval);
    py_retval = Py_BuildValue((char *) "N", py_NumericRange);
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_has_range(PyBambooArrayType *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_range();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooArrayType_get_element_type(PyBambooArrayType *self)
{
    PyObject *py_retval;
    bamboo::DistributedType const *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_element_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}

static PyMethodDef PyBambooArrayType_methods[] = {
    {(char *) "getRange", (PyCFunction) _wrap_PyBambooArrayType_getRange, METH_NOARGS, "Returns the range of sizes that the array may have." },
    {(char *) "get_array_size", (PyCFunction) _wrap_PyBambooArrayType_get_array_size, METH_NOARGS, "Returns the fixed number of elements in this array, or 0 if the array may contain a variable number of elements." },
    {(char *) "hasRange", (PyCFunction) _wrap_PyBambooArrayType_hasRange, METH_NOARGS, "Returns true if there is a constraint on the range of valid array sizes.  This is always true for fixed-size arrays." },
    {(char *) "getArraySize", (PyCFunction) _wrap_PyBambooArrayType_getArraySize, METH_NOARGS, "Returns the fixed number of elements in this array, or 0 if the array may contain a variable number of elements." },
    {(char *) "getElementType", (PyCFunction) _wrap_PyBambooArrayType_getElementType, METH_NOARGS, "Returns the type of the individual elements of this array." },
    {(char *) "get_range", (PyCFunction) _wrap_PyBambooArrayType_get_range, METH_NOARGS, "Returns the range of sizes that the array may have." },
    {(char *) "has_range", (PyCFunction) _wrap_PyBambooArrayType_has_range, METH_NOARGS, "Returns true if there is a constraint on the range of valid array sizes.  This is always true for fixed-size arrays." },
    {(char *) "get_element_type", (PyCFunction) _wrap_PyBambooArrayType_get_element_type, METH_NOARGS, "Returns the type of the individual elements of this array." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooArrayType__tp_dealloc(PyBambooArrayType *self)
{
        bamboo::ArrayType *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooArrayType__tp_richcompare (PyBambooArrayType *PYBINDGEN_UNUSED(self), PyBambooArrayType *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooArrayType_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooArrayType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.ArrayType",            /* tp_name */
    sizeof(PyBambooArrayType),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooArrayType__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "A NumericType can represent any of the basic number types (ie. integers, floats, etc).  A NumericType may also have a range and/or modulus to limit its possible values, and/or a divisor representing a fixed-point numeric convention.  A divisor scales up any range or modulus to constrain up to (constraint * divisor).",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooArrayType__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooArrayType_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooArrayType__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooMethod__tp_init(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new bamboo::Method();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooMethod_add_parameter(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooParameter *param;
    bamboo::Parameter *param_ptr;
    const char *keywords[] = {"param", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooParameter_Type, &param)) {
        return NULL;
    }
    param_ptr = (param ? param->obj : NULL);
    retval = self->obj->add_parameter(param_ptr);
    if (param) {
        param->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_getParameter(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Parameter *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooParameter *py_Parameter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_parameter(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Parameter = PyObject_New(PyBambooParameter, &PyBambooParameter_Type);
    py_Parameter->obj = new bamboo::Parameter((*retval));
    py_Parameter->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Parameter);
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_getNumParameters(PyBambooMethod *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_parameters();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_addParameter(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooParameter *param;
    bamboo::Parameter *param_ptr;
    const char *keywords[] = {"param", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooParameter_Type, &param)) {
        return NULL;
    }
    param_ptr = (param ? param->obj : NULL);
    retval = self->obj->add_parameter(param_ptr);
    if (param) {
        param->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_get_num_parameters(PyBambooMethod *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_parameters();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_get_parameter_by_name(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Parameter *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooParameter *py_Parameter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_parameter_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Parameter = PyObject_New(PyBambooParameter, &PyBambooParameter_Type);
    py_Parameter->obj = new bamboo::Parameter((*retval));
    py_Parameter->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Parameter);
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_get_parameter(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Parameter *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooParameter *py_Parameter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_parameter(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Parameter = PyObject_New(PyBambooParameter, &PyBambooParameter_Type);
    py_Parameter->obj = new bamboo::Parameter((*retval));
    py_Parameter->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Parameter);
    return py_retval;
}


PyObject *
_wrap_PyBambooMethod_getParameterByName(PyBambooMethod *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Parameter *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooParameter *py_Parameter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_parameter_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Parameter = PyObject_New(PyBambooParameter, &PyBambooParameter_Type);
    py_Parameter->obj = new bamboo::Parameter((*retval));
    py_Parameter->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Parameter);
    return py_retval;
}

static PyMethodDef PyBambooMethod_methods[] = {
    {(char *) "add_parameter", (PyCFunction) _wrap_PyBambooMethod_add_parameter, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Parameter to the Method returning false if there is a name conflict." },
    {(char *) "getParameter", (PyCFunction) _wrap_PyBambooMethod_getParameter, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th parameter of the method." },
    {(char *) "getNumParameters", (PyCFunction) _wrap_PyBambooMethod_getNumParameters, METH_NOARGS, "Returns the number of parameters/arguments of the method." },
    {(char *) "addParameter", (PyCFunction) _wrap_PyBambooMethod_addParameter, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Parameter to the Method returning false if there is a name conflict." },
    {(char *) "get_num_parameters", (PyCFunction) _wrap_PyBambooMethod_get_num_parameters, METH_NOARGS, "Returns the number of parameters/arguments of the method." },
    {(char *) "get_parameter_by_name", (PyCFunction) _wrap_PyBambooMethod_get_parameter_by_name, METH_KEYWORDS|METH_VARARGS, "Returns the requested parameter or None if there is no such param." },
    {(char *) "get_parameter", (PyCFunction) _wrap_PyBambooMethod_get_parameter, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th parameter of the method." },
    {(char *) "getParameterByName", (PyCFunction) _wrap_PyBambooMethod_getParameterByName, METH_KEYWORDS|METH_VARARGS, "Returns the requested parameter or None if there is no such param." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooMethod__tp_dealloc(PyBambooMethod *self)
{
        bamboo::Method *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooMethod__tp_richcompare (PyBambooMethod *PYBINDGEN_UNUSED(self), PyBambooMethod *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooMethod_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooMethod_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Method",            /* tp_name */
    sizeof(PyBambooMethod),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooMethod__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooMethod__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooMethod_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooMethod__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooStruct__tp_init(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyBambooModule *module;
    bamboo::Module *module_ptr;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"module", "name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooModule_Type, &module, &name, &name_len)) {
        return -1;
    }
    module_ptr = (module ? module->obj : NULL);
    name_std = std::string(name, name_len);
    self->obj = new bamboo::Struct(module_ptr, name_std);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooStruct_getFieldByName(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_field_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getId(PyBambooStruct *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_id();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getField(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getName(PyBambooStruct *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_addField(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooField *field;
    bamboo::Field *field_ptr;
    const char *keywords[] = {"field", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooField_Type, &field)) {
        return NULL;
    }
    field_ptr = (field ? field->obj : NULL);
    retval = self->obj->add_field(field_ptr);
    if (field) {
        field->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_field_by_id(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_name(PyBambooStruct *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getNumFields(PyBambooStruct *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_module(PyBambooStruct *self)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    PyBambooModule *py_Module;

    retval = self->obj->get_module();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_id(PyBambooStruct *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_id();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getFieldById(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_getModule(PyBambooStruct *self)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    PyBambooModule *py_Module;

    retval = self->obj->get_module();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_field(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_num_fields(PyBambooStruct *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_get_field_by_name(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_field_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooStruct_add_field(PyBambooStruct *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooField *field;
    bamboo::Field *field_ptr;
    const char *keywords[] = {"field", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooField_Type, &field)) {
        return NULL;
    }
    field_ptr = (field ? field->obj : NULL);
    retval = self->obj->add_field(field_ptr);
    if (field) {
        field->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyBambooStruct_methods[] = {
    {(char *) "getFieldByName", (PyCFunction) _wrap_PyBambooStruct_getFieldByName, METH_KEYWORDS|METH_VARARGS, "Returns the field with <name>, or None if no such field exists." },
    {(char *) "getId", (PyCFunction) _wrap_PyBambooStruct_getId, METH_NOARGS, "Returns a unique index number associated with this struct." },
    {(char *) "getField", (PyCFunction) _wrap_PyBambooStruct_getField, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field of the struct." },
    {(char *) "getName", (PyCFunction) _wrap_PyBambooStruct_getName, METH_NOARGS, "Returns the name of this struct." },
    {(char *) "addField", (PyCFunction) _wrap_PyBambooStruct_addField, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Field to the Struct returning false if there is a name conflict." },
    {(char *) "get_field_by_id", (PyCFunction) _wrap_PyBambooStruct_get_field_by_id, METH_KEYWORDS|METH_VARARGS, "Returns the field with the index <id>, or None if no such field exists." },
    {(char *) "get_name", (PyCFunction) _wrap_PyBambooStruct_get_name, METH_NOARGS, "Returns the name of this struct." },
    {(char *) "getNumFields", (PyCFunction) _wrap_PyBambooStruct_getNumFields, METH_NOARGS, "Returns the number of fields in the struct." },
    {(char *) "get_module", (PyCFunction) _wrap_PyBambooStruct_get_module, METH_NOARGS, "Returns the Module object that contains the struct." },
    {(char *) "get_id", (PyCFunction) _wrap_PyBambooStruct_get_id, METH_NOARGS, "Returns a unique index number associated with this struct." },
    {(char *) "getFieldById", (PyCFunction) _wrap_PyBambooStruct_getFieldById, METH_KEYWORDS|METH_VARARGS, "Returns the field with the index <id>, or None if no such field exists." },
    {(char *) "getModule", (PyCFunction) _wrap_PyBambooStruct_getModule, METH_NOARGS, "Returns the Module object that contains the struct." },
    {(char *) "get_field", (PyCFunction) _wrap_PyBambooStruct_get_field, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field of the struct." },
    {(char *) "get_num_fields", (PyCFunction) _wrap_PyBambooStruct_get_num_fields, METH_NOARGS, "Returns the number of fields in the struct." },
    {(char *) "get_field_by_name", (PyCFunction) _wrap_PyBambooStruct_get_field_by_name, METH_KEYWORDS|METH_VARARGS, "Returns the field with <name>, or None if no such field exists." },
    {(char *) "add_field", (PyCFunction) _wrap_PyBambooStruct_add_field, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Field to the Struct returning false if there is a name conflict." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooStruct__tp_dealloc(PyBambooStruct *self)
{
        bamboo::Struct *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooStruct__tp_richcompare (PyBambooStruct *PYBINDGEN_UNUSED(self), PyBambooStruct *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooStruct_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooStruct_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Struct",            /* tp_name */
    sizeof(PyBambooStruct),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooStruct__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooStruct__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooStruct_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooStruct__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooClass__tp_init(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyBambooModule *module;
    bamboo::Module *module_ptr;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"module", "name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooModule_Type, &module, &name, &name_len)) {
        return -1;
    }
    module_ptr = (module ? module->obj : NULL);
    name_std = std::string(name, name_len);
    self->obj = new bamboo::Class(module_ptr, name_std);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooClass_getNumBaseFields(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_base_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_addParent(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooClass *parent;
    bamboo::Class *parent_ptr;
    const char *keywords[] = {"parent", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooClass_Type, &parent)) {
        return NULL;
    }
    parent_ptr = (parent ? parent->obj : NULL);
    self->obj->add_parent(parent_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getParent(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_parent(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getNumChildren(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_children();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_parent(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_parent(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getNumParents(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_parents();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_base_field(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_base_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getConstructor(PyBambooClass *self)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    PyBambooField *py_Field;

    retval = self->obj->get_constructor();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_num_children(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_children();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_add_parent(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooClass *parent;
    bamboo::Class *parent_ptr;
    const char *keywords[] = {"parent", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooClass_Type, &parent)) {
        return NULL;
    }
    parent_ptr = (parent ? parent->obj : NULL);
    self->obj->add_parent(parent_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getBaseField(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_base_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_num_base_fields(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_base_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_num_parents(PyBambooClass *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_parents();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_getChild(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_child(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_child(PyBambooClass *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Class *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooClass *py_Class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_child(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Class = PyObject_New(PyBambooClass, &PyBambooClass_Type);
    py_Class->obj = new bamboo::Class((*retval));
    py_Class->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Class);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_get_constructor(PyBambooClass *self)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    PyBambooField *py_Field;

    retval = self->obj->get_constructor();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_has_constructor(PyBambooClass *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_constructor();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooClass_hasConstructor(PyBambooClass *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_constructor();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyBambooClass_methods[] = {
    {(char *) "getNumBaseFields", (PyCFunction) _wrap_PyBambooClass_getNumBaseFields, METH_NOARGS, "Returns the number of fields declared directly in this class." },
    {(char *) "addParent", (PyCFunction) _wrap_PyBambooClass_addParent, METH_KEYWORDS|METH_VARARGS, "Set this class as a subclass to target parent." },
    {(char *) "getParent", (PyCFunction) _wrap_PyBambooClass_getParent, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th parent-/super-class this class inherits from." },
    {(char *) "getNumChildren", (PyCFunction) _wrap_PyBambooClass_getNumChildren, METH_NOARGS, "Returns the number of subclasses that inherit from this class." },
    {(char *) "get_parent", (PyCFunction) _wrap_PyBambooClass_get_parent, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th parent-/super-class this class inherits from." },
    {(char *) "getNumParents", (PyCFunction) _wrap_PyBambooClass_getNumParents, METH_NOARGS, "Returns the number of superclasses this class inherits from." },
    {(char *) "get_base_field", (PyCFunction) _wrap_PyBambooClass_get_base_field, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field from the class excluding any inherited fields." },
    {(char *) "getConstructor", (PyCFunction) _wrap_PyBambooClass_getConstructor, METH_NOARGS, "Returns the constructor method for this class if it is defined, or nullptr if the class uses the default constructor." },
    {(char *) "get_num_children", (PyCFunction) _wrap_PyBambooClass_get_num_children, METH_NOARGS, "Returns the number of subclasses that inherit from this class." },
    {(char *) "add_parent", (PyCFunction) _wrap_PyBambooClass_add_parent, METH_KEYWORDS|METH_VARARGS, "Set this class as a subclass to target parent." },
    {(char *) "getBaseField", (PyCFunction) _wrap_PyBambooClass_getBaseField, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field from the class excluding any inherited fields." },
    {(char *) "get_num_base_fields", (PyCFunction) _wrap_PyBambooClass_get_num_base_fields, METH_NOARGS, "Returns the number of fields declared directly in this class." },
    {(char *) "get_num_parents", (PyCFunction) _wrap_PyBambooClass_get_num_parents, METH_NOARGS, "Returns the number of superclasses this class inherits from." },
    {(char *) "getChild", (PyCFunction) _wrap_PyBambooClass_getChild, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th child-/sub-class that inherits this class." },
    {(char *) "get_child", (PyCFunction) _wrap_PyBambooClass_get_child, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th child-/sub-class that inherits this class." },
    {(char *) "get_constructor", (PyCFunction) _wrap_PyBambooClass_get_constructor, METH_NOARGS, "Returns the constructor method for this class if it is defined, or nullptr if the class uses the default constructor." },
    {(char *) "has_constructor", (PyCFunction) _wrap_PyBambooClass_has_constructor, METH_NOARGS, "Returns true if this class has a constructor method, or false if it just uses the default constructor." },
    {(char *) "hasConstructor", (PyCFunction) _wrap_PyBambooClass_hasConstructor, METH_NOARGS, "Returns true if this class has a constructor method, or false if it just uses the default constructor." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooClass__tp_dealloc(PyBambooClass *self)
{
        bamboo::Class *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooClass__tp_richcompare (PyBambooClass *PYBINDGEN_UNUSED(self), PyBambooClass *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooClass_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooClass_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Class",            /* tp_name */
    sizeof(PyBambooClass),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooClass__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooClass__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooClass_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooClass__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooParameter__tp_init(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"type", "name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooDistributedType_Type, &type, &name, &name_len)) {
        return -1;
    }
    type_ptr = (type ? type->obj : NULL);
    name_std = std::string(name, name_len);
    self->obj = new bamboo::Parameter(type_ptr, name_std);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooParameter_set_name(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_getDefaultValue(PyBambooParameter *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_setName(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_hasDefaultValue(PyBambooParameter *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyBambooParameter_setDefaultValue__0(PyBambooParameter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooParameter_setDefaultValue__1(PyBambooParameter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooParameter_setDefaultValue(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooParameter_setDefaultValue__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooParameter_setDefaultValue__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyBambooParameter_getName(PyBambooParameter *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_getType(PyBambooParameter *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_get_default_value(PyBambooParameter *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_get_name(PyBambooParameter *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_set_type(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_has_default_value(PyBambooParameter *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_get_type(PyBambooParameter *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_getMethod(PyBambooParameter *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->get_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}



PyObject *
_wrap_PyBambooParameter_set_default_value__0(PyBambooParameter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooParameter_set_default_value__1(PyBambooParameter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooParameter_set_default_value(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooParameter_set_default_value__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooParameter_set_default_value__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyBambooParameter_get_method(PyBambooParameter *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->get_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}


PyObject *
_wrap_PyBambooParameter_setType(PyBambooParameter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyBambooParameter_methods[] = {
    {(char *) "set_name", (PyCFunction) _wrap_PyBambooParameter_set_name, METH_KEYWORDS|METH_VARARGS, "Sets the name of this parameter.  Returns false if a parameter with the same name already exists in the containing method." },
    {(char *) "getDefaultValue", (PyCFunction) _wrap_PyBambooParameter_getDefaultValue, METH_NOARGS, "Returns the default value for this parameter.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "setName", (PyCFunction) _wrap_PyBambooParameter_setName, METH_KEYWORDS|METH_VARARGS, "Sets the name of this parameter.  Returns false if a parameter with the same name already exists in the containing method." },
    {(char *) "hasDefaultValue", (PyCFunction) _wrap_PyBambooParameter_hasDefaultValue, METH_NOARGS, "Returns true if a default value was defined for this parameter." },
    {(char *) "setDefaultValue", (PyCFunction) _wrap_PyBambooParameter_setDefaultValue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "getName", (PyCFunction) _wrap_PyBambooParameter_getName, METH_NOARGS, "Returns the parameter's name.  An unnamed parameter returns the empty string." },
    {(char *) "getType", (PyCFunction) _wrap_PyBambooParameter_getType, METH_NOARGS, "Returns the DistributedType of the Parameter." },
    {(char *) "get_default_value", (PyCFunction) _wrap_PyBambooParameter_get_default_value, METH_NOARGS, "Returns the default value for this parameter.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "get_name", (PyCFunction) _wrap_PyBambooParameter_get_name, METH_NOARGS, "Returns the parameter's name.  An unnamed parameter returns the empty string." },
    {(char *) "set_type", (PyCFunction) _wrap_PyBambooParameter_set_type, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the parameter and clear's the default value.  Returns false if a parameter cannot represent <type>." },
    {(char *) "has_default_value", (PyCFunction) _wrap_PyBambooParameter_has_default_value, METH_NOARGS, "Returns true if a default value was defined for this parameter." },
    {(char *) "get_type", (PyCFunction) _wrap_PyBambooParameter_get_type, METH_NOARGS, "Returns the DistributedType of the Parameter." },
    {(char *) "getMethod", (PyCFunction) _wrap_PyBambooParameter_getMethod, METH_NOARGS, "Returns the Method that contains the Parameter." },
    {(char *) "set_default_value", (PyCFunction) _wrap_PyBambooParameter_set_default_value, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "get_method", (PyCFunction) _wrap_PyBambooParameter_get_method, METH_NOARGS, "Returns the Method that contains the Parameter." },
    {(char *) "setType", (PyCFunction) _wrap_PyBambooParameter_setType, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the parameter and clear's the default value.  Returns false if a parameter cannot represent <type>." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooParameter__tp_dealloc(PyBambooParameter *self)
{
        bamboo::Parameter *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooParameter__tp_richcompare (PyBambooParameter *PYBINDGEN_UNUSED(self), PyBambooParameter *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooParameter_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooParameter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Parameter",            /* tp_name */
    sizeof(PyBambooParameter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooParameter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooParameter__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooParameter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooParameter__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooField__tp_init(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"type", "name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooDistributedType_Type, &type, &name, &name_len)) {
        return -1;
    }
    type_ptr = (type ? type->obj : NULL);
    name_std = std::string(name, name_len);
    self->obj = new bamboo::Field(type_ptr, name_std);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyBambooField_set_name(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_setName(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_getDefaultValue(PyBambooField *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}


PyObject *
_wrap_PyBambooField_getStruct(PyBambooField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->get_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}


PyObject *
_wrap_PyBambooField_hasDefaultValue(PyBambooField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_get_struct(PyBambooField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->get_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}



PyObject *
_wrap_PyBambooField_setDefaultValue__0(PyBambooField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooField_setDefaultValue__1(PyBambooField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooField_setDefaultValue(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooField_setDefaultValue__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooField_setDefaultValue__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyBambooField_getName(PyBambooField *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooField_getType(PyBambooField *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooField_get_default_value(PyBambooField *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}


PyObject *
_wrap_PyBambooField_get_name(PyBambooField *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_name();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyBambooField_set_type(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_has_default_value(PyBambooField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_get_id(PyBambooField *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_id();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooField_get_type(PyBambooField *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}


PyObject *
_wrap_PyBambooField_getId(PyBambooField *self)
{
    PyObject *py_retval;
    unsigned int retval;

    retval = self->obj->get_id();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyBambooField_set_default_value__0(PyBambooField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooField_set_default_value__1(PyBambooField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooField_set_default_value(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooField_set_default_value__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooField_set_default_value__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyBambooField_setType(PyBambooField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyBambooField_methods[] = {
    {(char *) "set_name", (PyCFunction) _wrap_PyBambooField_set_name, METH_KEYWORDS|METH_VARARGS, "Sets the name of this field.  Returns false if a field with the same name already exists in the containing method." },
    {(char *) "setName", (PyCFunction) _wrap_PyBambooField_setName, METH_KEYWORDS|METH_VARARGS, "Sets the name of this field.  Returns false if a field with the same name already exists in the containing method." },
    {(char *) "getDefaultValue", (PyCFunction) _wrap_PyBambooField_getDefaultValue, METH_NOARGS, "Returns the default value for this field.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "getStruct", (PyCFunction) _wrap_PyBambooField_getStruct, METH_NOARGS, "Returns the Struct that contains this field." },
    {(char *) "hasDefaultValue", (PyCFunction) _wrap_PyBambooField_hasDefaultValue, METH_NOARGS, "Returns true if a default value was defined for this field." },
    {(char *) "get_struct", (PyCFunction) _wrap_PyBambooField_get_struct, METH_NOARGS, "Returns the Struct that contains this field." },
    {(char *) "setDefaultValue", (PyCFunction) _wrap_PyBambooField_setDefaultValue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "getName", (PyCFunction) _wrap_PyBambooField_getName, METH_NOARGS, "Returns the field's name.  An unnamed field returns the empty string." },
    {(char *) "getType", (PyCFunction) _wrap_PyBambooField_getType, METH_NOARGS, "Returns the DistributedType of the field." },
    {(char *) "get_default_value", (PyCFunction) _wrap_PyBambooField_get_default_value, METH_NOARGS, "Returns the default value for this field.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "get_name", (PyCFunction) _wrap_PyBambooField_get_name, METH_NOARGS, "Returns the field's name.  An unnamed field returns the empty string." },
    {(char *) "set_type", (PyCFunction) _wrap_PyBambooField_set_type, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the field and clear's the default value.  Returns false if a field cannot represent <type>." },
    {(char *) "has_default_value", (PyCFunction) _wrap_PyBambooField_has_default_value, METH_NOARGS, "Returns true if a default value was defined for this field." },
    {(char *) "get_id", (PyCFunction) _wrap_PyBambooField_get_id, METH_NOARGS, "Returns a unique index number associated with this field." },
    {(char *) "get_type", (PyCFunction) _wrap_PyBambooField_get_type, METH_NOARGS, "Returns the DistributedType of the field." },
    {(char *) "getId", (PyCFunction) _wrap_PyBambooField_getId, METH_NOARGS, "Returns a unique index number associated with this field." },
    {(char *) "set_default_value", (PyCFunction) _wrap_PyBambooField_set_default_value, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "setType", (PyCFunction) _wrap_PyBambooField_setType, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the field and clear's the default value.  Returns false if a field cannot represent <type>." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooField__tp_dealloc(PyBambooField *self)
{
        bamboo::Field *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooField__tp_richcompare (PyBambooField *PYBINDGEN_UNUSED(self), PyBambooField *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooField_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooField_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Field",            /* tp_name */
    sizeof(PyBambooField),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooField__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooField__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooField_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooField__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooMolecularField__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'MolecularField' cannot be constructed ()");
    return -1;
}

PyObject *
_wrap_PyBambooMolecularField_as_struct(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->as_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_as_array(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::ArrayType *retval;
    PyBambooArrayType *py_ArrayType;

    retval = self->obj->as_array();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_ArrayType = PyObject_New(PyBambooArrayType, &PyBambooArrayType_Type);
    py_ArrayType->obj = new bamboo::ArrayType((*retval));
    py_ArrayType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_ArrayType);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getStruct(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->get_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_as_method(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->as_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_as_numeric(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::NumericType *retval;
    PyBambooNumericType *py_NumericType;

    retval = self->obj->as_numeric();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_NumericType = PyObject_New(PyBambooNumericType, &PyBambooNumericType_Type);
    py_NumericType->obj = new bamboo::NumericType((*retval));
    py_NumericType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_NumericType);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getSize(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_size();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_type(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_module(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    PyBambooModule *py_Module;

    retval = self->obj->get_module();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_setType(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_alias(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_alias();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_hasDefaultValue(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_hasFixedSize(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_fixed_size();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_default_value(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_size(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_size();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_field_by_id(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_has_alias(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_alias();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_has_fixed_size(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_fixed_size();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_field(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_num_fields(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_asStruct(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->as_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_subtype(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Subtype retval;

    retval = self->obj->get_subtype();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_asMethod(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Method *retval;
    PyBambooMethod *py_Method;

    retval = self->obj->as_method();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Method = PyObject_New(PyBambooMethod, &PyBambooMethod_Type);
    py_Method->obj = new bamboo::Method((*retval));
    py_Method->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Method);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getFieldByName(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_field_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getDefaultValue(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    PyBambooTypeDataHandle *py_TypeDataHandle;

    TypeDataHandle retval = self->obj->get_default_value();
    py_TypeDataHandle = PyObject_New(PyBambooTypeDataHandle, &PyBambooTypeDataHandle_Type);
    py_TypeDataHandle->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeDataHandle->obj = new bamboo::TypeDataHandle(retval);
    py_retval = Py_BuildValue((char *) "N", py_TypeDataHandle);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_setName(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_asArray(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::ArrayType *retval;
    PyBambooArrayType *py_ArrayType;

    retval = self->obj->as_array();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_ArrayType = PyObject_New(PyBambooArrayType, &PyBambooArrayType_Type);
    py_ArrayType->obj = new bamboo::ArrayType((*retval));
    py_ArrayType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_ArrayType);
    return py_retval;
}


PyObject *
_wrap_PyBambooMolecularField_setDefaultValue__0(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_setDefaultValue__1(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooMolecularField_setDefaultValue(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooMolecularField_setDefaultValue__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooMolecularField_setDefaultValue__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
_wrap_PyBambooMolecularField_getType(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::DistributedType *retval;
    PyBambooDistributedType *py_DistributedType;

    retval = self->obj->get_type();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_DistributedType = PyObject_New(PyBambooDistributedType, &PyBambooDistributedType_Type);
    py_DistributedType->obj = new bamboo::DistributedType((*retval));
    py_DistributedType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_DistributedType);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_get_struct(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Struct *retval;
    PyBambooStruct *py_Struct;

    retval = self->obj->get_struct();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Struct = PyObject_New(PyBambooStruct, &PyBambooStruct_Type);
    py_Struct->obj = new bamboo::Struct((*retval));
    py_Struct->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Struct);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_set_type(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *keywords[] = {"type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooDistributedType_Type, &type)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    retval = self->obj->set_type(type_ptr);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getAlias(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    std::string retval;

    retval = self->obj->get_alias();
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_add_field(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooField *field;
    bamboo::Field *field_ptr;
    const char *keywords[] = {"field", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooField_Type, &field)) {
        return NULL;
    }
    field_ptr = (field ? field->obj : NULL);
    retval = self->obj->add_field(field_ptr);
    if (field) {
        field->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getFieldById(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int id;
    const char *keywords[] = {"id", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->get_field_by_id(id);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getModule(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    PyBambooModule *py_Module;

    retval = self->obj->get_module();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_setAlias(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *alias;
    Py_ssize_t alias_len;
    std::string alias_std;
    const char *keywords[] = {"alias", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &alias, &alias_len)) {
        return NULL;
    }
    alias_std = std::string(alias, alias_len);
    self->obj->set_alias(alias_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_asNumeric(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::NumericType *retval;
    PyBambooNumericType *py_NumericType;

    retval = self->obj->as_numeric();
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_NumericType = PyObject_New(PyBambooNumericType, &PyBambooNumericType_Type);
    py_NumericType->obj = new bamboo::NumericType((*retval));
    py_NumericType->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_NumericType);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_set_name(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->set_name(name_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_hasAlias(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_alias();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getField(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->get_field(n);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_addField(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooField *field;
    bamboo::Field *field_ptr;
    const char *keywords[] = {"field", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooField_Type, &field)) {
        return NULL;
    }
    field_ptr = (field ? field->obj : NULL);
    retval = self->obj->add_field(field_ptr);
    if (field) {
        field->obj = NULL;
    }
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getNumFields(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    size_t retval;

    retval = self->obj->get_num_fields();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_getSubtype(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bamboo::Subtype retval;

    retval = self->obj->get_subtype();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_has_default_value(PyBambooMolecularField *self)
{
    PyObject *py_retval;
    bool retval;

    retval = self->obj->has_default_value();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyBambooMolecularField_set_default_value__0(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooTypeData *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooTypeData_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooTypeData *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_set_default_value__1(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyBambooBuffer *value;
    const char *keywords[] = {"value", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooBuffer_Type, &value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->set_default_value(*((PyBambooBuffer *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyBambooMolecularField_set_default_value(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooMolecularField_set_default_value__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooMolecularField_set_default_value__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
_wrap_PyBambooMolecularField_get_field_by_name(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Field *retval;
    const char *name;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};
    PyBambooField *py_Field;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    name_std = std::string(name, name_len);
    retval = self->obj->get_field_by_name(name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Field = PyObject_New(PyBambooField, &PyBambooField_Type);
    py_Field->obj = new bamboo::Field((*retval));
    py_Field->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Field);
    return py_retval;
}

PyObject *
_wrap_PyBambooMolecularField_set_alias(PyBambooMolecularField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *alias;
    Py_ssize_t alias_len;
    std::string alias_std;
    const char *keywords[] = {"alias", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &alias, &alias_len)) {
        return NULL;
    }
    alias_std = std::string(alias, alias_len);
    self->obj->set_alias(alias_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyBambooMolecularField_methods[] = {
    {(char *) "as_struct", (PyCFunction) _wrap_PyBambooMolecularField_as_struct, METH_NOARGS, "Returns this as a Struct if it is a struct, or None otherwise." },
    {(char *) "as_array", (PyCFunction) _wrap_PyBambooMolecularField_as_array, METH_NOARGS, "Returns this as an ArrayType if it is an array, or None otherwise." },
    {(char *) "getStruct", (PyCFunction) _wrap_PyBambooMolecularField_getStruct, METH_NOARGS, "Returns the Struct that contains this field." },
    {(char *) "as_method", (PyCFunction) _wrap_PyBambooMolecularField_as_method, METH_NOARGS, "Returns this as a Method if it is a method, or None otherwise." },
    {(char *) "as_numeric", (PyCFunction) _wrap_PyBambooMolecularField_as_numeric, METH_NOARGS, "Returns this as a NumericType if it is numeric, or None otherwise." },
    {(char *) "getSize", (PyCFunction) _wrap_PyBambooMolecularField_getSize, METH_NOARGS, "Returns the size of the DistributedType in bytes or 0 if it is variable." },
    {(char *) "get_type", (PyCFunction) _wrap_PyBambooMolecularField_get_type, METH_NOARGS, "Returns the DistributedType of the field." },
    {(char *) "get_module", (PyCFunction) _wrap_PyBambooMolecularField_get_module, METH_NOARGS, "Returns the Module object that contains the struct." },
    {(char *) "setType", (PyCFunction) _wrap_PyBambooMolecularField_setType, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the field and clear's the default value.  Returns false if a field cannot represent <type>." },
    {(char *) "get_alias", (PyCFunction) _wrap_PyBambooMolecularField_get_alias, METH_NOARGS, "Returns the name used to define the type, or the empty string." },
    {(char *) "hasDefaultValue", (PyCFunction) _wrap_PyBambooMolecularField_hasDefaultValue, METH_NOARGS, "Returns true if a default value was defined for this field." },
    {(char *) "hasFixedSize", (PyCFunction) _wrap_PyBambooMolecularField_hasFixedSize, METH_NOARGS, "Returns true if the DistributedType has a fixed size in bytes." },
    {(char *) "get_default_value", (PyCFunction) _wrap_PyBambooMolecularField_get_default_value, METH_NOARGS, "Returns the default value for this field.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "get_size", (PyCFunction) _wrap_PyBambooMolecularField_get_size, METH_NOARGS, "Returns the size of the DistributedType in bytes or 0 if it is variable." },
    {(char *) "get_field_by_id", (PyCFunction) _wrap_PyBambooMolecularField_get_field_by_id, METH_KEYWORDS|METH_VARARGS, "Returns the field with the index <id>, or None if no such field exists." },
    {(char *) "has_alias", (PyCFunction) _wrap_PyBambooMolecularField_has_alias, METH_NOARGS, "Returns true if this type was defined the an aliased name." },
    {(char *) "has_fixed_size", (PyCFunction) _wrap_PyBambooMolecularField_has_fixed_size, METH_NOARGS, "Returns true if the DistributedType has a fixed size in bytes." },
    {(char *) "get_field", (PyCFunction) _wrap_PyBambooMolecularField_get_field, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field of the struct." },
    {(char *) "get_num_fields", (PyCFunction) _wrap_PyBambooMolecularField_get_num_fields, METH_NOARGS, "Returns the number of fields in the struct." },
    {(char *) "asStruct", (PyCFunction) _wrap_PyBambooMolecularField_asStruct, METH_NOARGS, "Returns this as a Struct if it is a struct, or None otherwise." },
    {(char *) "get_subtype", (PyCFunction) _wrap_PyBambooMolecularField_get_subtype, METH_NOARGS, "Returns the type's fundamental type as an integer constant." },
    {(char *) "asMethod", (PyCFunction) _wrap_PyBambooMolecularField_asMethod, METH_NOARGS, "Returns this as a Method if it is a method, or None otherwise." },
    {(char *) "getFieldByName", (PyCFunction) _wrap_PyBambooMolecularField_getFieldByName, METH_KEYWORDS|METH_VARARGS, "Returns the field with <name>, or None if no such field exists." },
    {(char *) "getDefaultValue", (PyCFunction) _wrap_PyBambooMolecularField_getDefaultValue, METH_NOARGS, "Returns the default value for this field.  If a default value hasn't been set, returns an implicit default." },
    {(char *) "setName", (PyCFunction) _wrap_PyBambooMolecularField_setName, METH_KEYWORDS|METH_VARARGS, "Sets the name of this field.  Returns false if a field with the same name already exists in the containing method." },
    {(char *) "asArray", (PyCFunction) _wrap_PyBambooMolecularField_asArray, METH_NOARGS, "Returns this as an ArrayType if it is an array, or None otherwise." },
    {(char *) "setDefaultValue", (PyCFunction) _wrap_PyBambooMolecularField_setDefaultValue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "getType", (PyCFunction) _wrap_PyBambooMolecularField_getType, METH_NOARGS, "Returns the DistributedType of the field." },
    {(char *) "get_struct", (PyCFunction) _wrap_PyBambooMolecularField_get_struct, METH_NOARGS, "Returns the Struct that contains this field." },
    {(char *) "set_type", (PyCFunction) _wrap_PyBambooMolecularField_set_type, METH_KEYWORDS|METH_VARARGS, "Sets the DistributedType of the field and clear's the default value.  Returns false if a field cannot represent <type>." },
    {(char *) "getAlias", (PyCFunction) _wrap_PyBambooMolecularField_getAlias, METH_NOARGS, "Returns the name used to define the type, or the empty string." },
    {(char *) "add_field", (PyCFunction) _wrap_PyBambooMolecularField_add_field, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Field to the Struct returning false if there is a name conflict." },
    {(char *) "getFieldById", (PyCFunction) _wrap_PyBambooMolecularField_getFieldById, METH_KEYWORDS|METH_VARARGS, "Returns the field with the index <id>, or None if no such field exists." },
    {(char *) "getModule", (PyCFunction) _wrap_PyBambooMolecularField_getModule, METH_NOARGS, "Returns the Module object that contains the struct." },
    {(char *) "setAlias", (PyCFunction) _wrap_PyBambooMolecularField_setAlias, METH_KEYWORDS|METH_VARARGS, "Gives this type an alternate name <alias>." },
    {(char *) "asNumeric", (PyCFunction) _wrap_PyBambooMolecularField_asNumeric, METH_NOARGS, "Returns this as a NumericType if it is numeric, or None otherwise." },
    {(char *) "set_name", (PyCFunction) _wrap_PyBambooMolecularField_set_name, METH_KEYWORDS|METH_VARARGS, "Sets the name of this field.  Returns false if a field with the same name already exists in the containing method." },
    {(char *) "hasAlias", (PyCFunction) _wrap_PyBambooMolecularField_hasAlias, METH_NOARGS, "Returns true if this type was defined the an aliased name." },
    {(char *) "getField", (PyCFunction) _wrap_PyBambooMolecularField_getField, METH_KEYWORDS|METH_VARARGS, "Returns the <n>th field of the struct." },
    {(char *) "addField", (PyCFunction) _wrap_PyBambooMolecularField_addField, METH_KEYWORDS|METH_VARARGS, "Gives ownership of the Field to the Struct returning false if there is a name conflict." },
    {(char *) "getNumFields", (PyCFunction) _wrap_PyBambooMolecularField_getNumFields, METH_NOARGS, "Returns the number of fields in the struct." },
    {(char *) "getSubtype", (PyCFunction) _wrap_PyBambooMolecularField_getSubtype, METH_NOARGS, "Returns the type's fundamental type as an integer constant." },
    {(char *) "has_default_value", (PyCFunction) _wrap_PyBambooMolecularField_has_default_value, METH_NOARGS, "Returns true if a default value was defined for this field." },
    {(char *) "set_default_value", (PyCFunction) _wrap_PyBambooMolecularField_set_default_value, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "get_field_by_name", (PyCFunction) _wrap_PyBambooMolecularField_get_field_by_name, METH_KEYWORDS|METH_VARARGS, "Returns the field with <name>, or None if no such field exists." },
    {(char *) "set_alias", (PyCFunction) _wrap_PyBambooMolecularField_set_alias, METH_KEYWORDS|METH_VARARGS, "Gives this type an alternate name <alias>." },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooMolecularField__tp_dealloc(PyBambooMolecularField *self)
{
        bamboo::MolecularField *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooMolecularField__tp_richcompare (PyBambooMolecularField *PYBINDGEN_UNUSED(self), PyBambooMolecularField *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooMolecularField_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooMolecularField_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.MolecularField",            /* tp_name */
    sizeof(PyBambooMolecularField),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooMolecularField__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooMolecularField__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooMolecularField_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooMolecularField__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooTypeData__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'TypeData' cannot be constructed ()");
    return -1;
}

static PyMethodDef PyBambooTypeData_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooTypeData__tp_dealloc(PyBambooTypeData *self)
{
        bamboo::TypeData *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooTypeData__tp_richcompare (PyBambooTypeData *PYBINDGEN_UNUSED(self), PyBambooTypeData *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooTypeData_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooTypeData_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.TypeData",            /* tp_name */
    sizeof(PyBambooTypeData),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooTypeData__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooTypeData__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooTypeData_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooTypeData__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooTypeDataHandle__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'TypeDataHandle' cannot be constructed ()");
    return -1;
}

static PyMethodDef PyBambooTypeDataHandle_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooTypeDataHandle__tp_dealloc(PyBambooTypeDataHandle *self)
{
        bamboo::TypeDataHandle *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooTypeDataHandle__tp_richcompare (PyBambooTypeDataHandle *PYBINDGEN_UNUSED(self), PyBambooTypeDataHandle *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooTypeDataHandle_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooTypeDataHandle_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.TypeDataHandle",            /* tp_name */
    sizeof(PyBambooTypeDataHandle),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooTypeDataHandle__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooTypeDataHandle__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooTypeDataHandle_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooTypeDataHandle__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyBambooImport__get_module(PyBambooImport *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "s#", (self->obj->module).c_str(), (self->obj->module).size());
    return py_retval;
}
static int _wrap_PyBambooImport__set_module(PyBambooImport *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    const char *retval_ptr;
    Py_ssize_t retval_len;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "s#", &retval_ptr, &retval_len)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->module = std::string(retval_ptr, retval_len);
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooImport__get_symbols(PyBambooImport *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    Pystd__vector__lt__std__string__gt__ *py_std__vector__lt__std__string__gt__;

    py_std__vector__lt__std__string__gt__ = PyObject_New(Pystd__vector__lt__std__string__gt__, &Pystd__vector__lt__std__string__gt___Type);
    py_std__vector__lt__std__string__gt__->obj = new std::vector<std::string>(self->obj->symbols);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__std__string__gt__);
    return py_retval;
}
static int _wrap_PyBambooImport__set_symbols(PyBambooImport *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O&", _wrap_convert_py2c__std__vector__lt___std__string___gt__, &self->obj->symbols)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyBambooImport__getsets[] = {
    {
        (char*) "symbols", /* attribute name */
        (getter) _wrap_PyBambooImport__get_symbols, /* C function to get the attribute */
        (setter) _wrap_PyBambooImport__set_symbols, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "module", /* attribute name */
        (getter) _wrap_PyBambooImport__get_module, /* C function to get the attribute */
        (setter) _wrap_PyBambooImport__set_module, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyBambooImport__tp_init__0(PyBambooImport *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Import();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooImport__tp_init__1(PyBambooImport *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyBambooImport *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooImport_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Import(*((PyBambooImport *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooImport__tp_init__2(PyBambooImport *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *moduleName;
    Py_ssize_t moduleName_len;
    std::string moduleName_std;
    const char *keywords[] = {"moduleName", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &moduleName, &moduleName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    moduleName_std = std::string(moduleName, moduleName_len);
    self->obj = new bamboo::Import(moduleName_std);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyBambooImport__tp_init(PyBambooImport *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyBambooImport__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooImport__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyBambooImport__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyBambooImport__copy__(PyBambooImport *self)
{

    PyBambooImport *py_copy;
    py_copy = PyObject_New(PyBambooImport, &PyBambooImport_Type);
    py_copy->obj = new bamboo::Import(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyBambooImport_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyBambooImport__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooImport__tp_dealloc(PyBambooImport *self)
{
        bamboo::Import *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooImport__tp_richcompare (PyBambooImport *PYBINDGEN_UNUSED(self), PyBambooImport *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooImport_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooImport_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Import",            /* tp_name */
    sizeof(PyBambooImport),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooImport__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooImport__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooImport_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyBambooImport__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooImport__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyBambooNumber__get_type(PyBambooNumber *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->type);
    return py_retval;
}
static int _wrap_PyBambooNumber__set_type(PyBambooNumber *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooNumber__get_integer(PyBambooNumber *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "L", self->obj->integer);
    return py_retval;
}
static int _wrap_PyBambooNumber__set_integer(PyBambooNumber *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "L", &self->obj->integer)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooNumber__get_uinteger(PyBambooNumber *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "K", self->obj->uinteger);
    return py_retval;
}
static int _wrap_PyBambooNumber__set_uinteger(PyBambooNumber *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "K", &self->obj->uinteger)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooNumber__get_floating(PyBambooNumber *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "d", self->obj->floating);
    return py_retval;
}
static int _wrap_PyBambooNumber__set_floating(PyBambooNumber *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &self->obj->floating)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyBambooNumber__getsets[] = {
    {
        (char*) "integer", /* attribute name */
        (getter) _wrap_PyBambooNumber__get_integer, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumber__set_integer, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "floating", /* attribute name */
        (getter) _wrap_PyBambooNumber__get_floating, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumber__set_floating, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "type", /* attribute name */
        (getter) _wrap_PyBambooNumber__get_type, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumber__set_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "uinteger", /* attribute name */
        (getter) _wrap_PyBambooNumber__get_uinteger, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumber__set_uinteger, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyBambooNumber__tp_init__0(PyBambooNumber *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Number();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyBambooNumber__tp_init__1(PyBambooNumber *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyBambooNumber *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyBambooNumber_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new bamboo::Number(*((PyBambooNumber *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyBambooNumber__tp_init(PyBambooNumber *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyBambooNumber__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyBambooNumber__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyBambooNumber__copy__(PyBambooNumber *self)
{

    PyBambooNumber *py_copy;
    py_copy = PyObject_New(PyBambooNumber, &PyBambooNumber_Type);
    py_copy->obj = new bamboo::Number(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyBambooNumber_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyBambooNumber__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooNumber__tp_dealloc(PyBambooNumber *self)
{
        bamboo::Number *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooNumber__tp_richcompare (PyBambooNumber *PYBINDGEN_UNUSED(self), PyBambooNumber *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooNumber_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooNumber_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Number",            /* tp_name */
    sizeof(PyBambooNumber),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooNumber__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooNumber__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooNumber_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyBambooNumber__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooNumber__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyBambooNumericRange__get_type(PyBambooNumericRange *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->type);
    return py_retval;
}
static int _wrap_PyBambooNumericRange__set_type(PyBambooNumericRange *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooNumericRange__get_min(PyBambooNumericRange *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyBambooNumber *py_Number;

    py_Number = PyObject_New(PyBambooNumber, &PyBambooNumber_Type);
    py_Number->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Number->obj = new bamboo::Number(self->obj->min);
    py_retval = Py_BuildValue((char *) "N", py_Number);
    return py_retval;
}
static int _wrap_PyBambooNumericRange__set_min(PyBambooNumericRange *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyBambooNumber *tmp_Number;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyBambooNumber_Type, &tmp_Number)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->min = *tmp_Number->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyBambooNumericRange__get_max(PyBambooNumericRange *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyBambooNumber *py_Number;

    py_Number = PyObject_New(PyBambooNumber, &PyBambooNumber_Type);
    py_Number->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Number->obj = new bamboo::Number(self->obj->max);
    py_retval = Py_BuildValue((char *) "N", py_Number);
    return py_retval;
}
static int _wrap_PyBambooNumericRange__set_max(PyBambooNumericRange *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyBambooNumber *tmp_Number;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyBambooNumber_Type, &tmp_Number)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->max = *tmp_Number->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyBambooNumericRange__getsets[] = {
    {
        (char*) "max", /* attribute name */
        (getter) _wrap_PyBambooNumericRange__get_max, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumericRange__set_max, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "type", /* attribute name */
        (getter) _wrap_PyBambooNumericRange__get_type, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumericRange__set_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "min", /* attribute name */
        (getter) _wrap_PyBambooNumericRange__get_min, /* C function to get the attribute */
        (setter) _wrap_PyBambooNumericRange__set_min, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

static int
_wrap_PyBambooNumericRange__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'NumericRange' cannot be constructed ()");
    return -1;
}

static PyMethodDef PyBambooNumericRange_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooNumericRange__tp_dealloc(PyBambooNumericRange *self)
{
        bamboo::NumericRange *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooNumericRange__tp_richcompare (PyBambooNumericRange *PYBINDGEN_UNUSED(self), PyBambooNumericRange *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooNumericRange_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooNumericRange_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.NumericRange",            /* tp_name */
    sizeof(PyBambooNumericRange),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooNumericRange__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooNumericRange__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooNumericRange_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyBambooNumericRange__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooNumericRange__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__vector__lt__std__string__gt__Iter__tp_clear(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt__std__string__gt__Iter__tp_traverse(Pystd__vector__lt__std__string__gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc(Pystd__vector__lt__std__string__gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt____tp_iter(Pystd__vector__lt__std__string__gt__ *self)
{
    Pystd__vector__lt__std__string__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__std__string__gt__Iter, &Pystd__vector__lt__std__string__gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector<std::string>::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext(Pystd__vector__lt__std__string__gt__Iter *self)
{
    PyObject *py_retval;
    std::vector<std::string>::iterator iter;

    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "s#", ((*iter)).c_str(), ((*iter)).size());
    return py_retval;
}

int _wrap_convert_py2c__std__string(PyObject *value, std::string *address)
{
    PyObject *py_retval;
    const char *retval_ptr;
    Py_ssize_t retval_len;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "s#", &retval_ptr, &retval_len)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = std::string(retval_ptr, retval_len);
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt__std__string__gt___Type)) {
        *container = *((Pystd__vector__lt__std__string__gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            std::string item;
            if (!_wrap_convert_py2c__std__string(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt__std__string__gt__ instance, or a list of std::string");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt__std__string__gt____tp_init(Pystd__vector__lt__std__string__gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector<std::string>;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___std__string___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt__std__string__gt___Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Std__vector__lt__std__string__gt__",            /* tp_name */
    sizeof(Pystd__vector__lt__std__string__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__std__string__gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt__std__string__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.module.Std__vector__lt__std__string__gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt__std__string__gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt__std__string__gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt__std__string__gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- enumerations --- */





#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_module_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo.module",
    NULL,
    -1,
    bamboo_module_functions,
};
#endif

static PyObject *
initbamboo_module(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_module_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo.module", bamboo_module_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    /* Register the 'bamboo::Module' class */
    if (PyType_Ready(&PyBambooModule_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Module", (PyObject *) &PyBambooModule_Type);
    /* Register the 'bamboo::DistributedType' class */
    if (PyType_Ready(&PyBambooDistributedType_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "DistributedType", (PyObject *) &PyBambooDistributedType_Type);
    /* Register the 'bamboo::NumericType' class */
    PyBambooNumericType_Type.tp_base = &PyBambooDistributedType_Type;
    if (PyType_Ready(&PyBambooNumericType_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "NumericType", (PyObject *) &PyBambooNumericType_Type);
    /* Register the 'bamboo::ArrayType' class */
    PyBambooArrayType_Type.tp_base = &PyBambooDistributedType_Type;
    if (PyType_Ready(&PyBambooArrayType_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "ArrayType", (PyObject *) &PyBambooArrayType_Type);
    /* Register the 'bamboo::Method' class */
    PyBambooMethod_Type.tp_base = &PyBambooDistributedType_Type;
    if (PyType_Ready(&PyBambooMethod_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Method", (PyObject *) &PyBambooMethod_Type);
    /* Register the 'bamboo::Struct' class */
    PyBambooStruct_Type.tp_base = &PyBambooDistributedType_Type;
    if (PyType_Ready(&PyBambooStruct_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Struct", (PyObject *) &PyBambooStruct_Type);
    /* Register the 'bamboo::Class' class */
    PyBambooClass_Type.tp_base = &PyBambooStruct_Type;
    if (PyType_Ready(&PyBambooClass_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Class", (PyObject *) &PyBambooClass_Type);
    /* Register the 'bamboo::Parameter' class */
    if (PyType_Ready(&PyBambooParameter_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Parameter", (PyObject *) &PyBambooParameter_Type);
    /* Register the 'bamboo::Field' class */
    if (PyType_Ready(&PyBambooField_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Field", (PyObject *) &PyBambooField_Type);
    /* Register the 'bamboo::MolecularField' class */
    PyBambooMolecularField_Type.tp_base = &PyBambooField_Type;
    PyBambooMolecularField_Type.tp_bases = PyTuple_New(2);
        Py_INCREF((PyObject *) &PyBambooField_Type);
        PyTuple_SET_ITEM(PyBambooMolecularField_Type.tp_bases, 0, (PyObject *) &PyBambooField_Type);
        Py_INCREF((PyObject *) &PyBambooStruct_Type);
        PyTuple_SET_ITEM(PyBambooMolecularField_Type.tp_bases, 1, (PyObject *) &PyBambooStruct_Type);
    if (PyType_Ready(&PyBambooMolecularField_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "MolecularField", (PyObject *) &PyBambooMolecularField_Type);
    /* Register the 'bamboo::TypeData' class */
    if (PyType_Ready(&PyBambooTypeData_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "TypeData", (PyObject *) &PyBambooTypeData_Type);
    /* Register the 'bamboo::TypeDataHandle' class */
    if (PyType_Ready(&PyBambooTypeDataHandle_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "TypeDataHandle", (PyObject *) &PyBambooTypeDataHandle_Type);
    /* Register the 'bamboo::Import' class */
    if (PyType_Ready(&PyBambooImport_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Import", (PyObject *) &PyBambooImport_Type);
    /* Register the 'bamboo::Number' class */
    if (PyType_Ready(&PyBambooNumber_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Number", (PyObject *) &PyBambooNumber_Type);
    /* Register the 'bamboo::NumericRange' class */
    if (PyType_Ready(&PyBambooNumericRange_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "NumericRange", (PyObject *) &PyBambooNumericRange_Type);
    /* Register the 'std::vector<std::string>' class */
    if (PyType_Ready(&Pystd__vector__lt__std__string__gt___Type)) {
        return NULL;
    }
    if (PyType_Ready(&Pystd__vector__lt__std__string__gt__Iter_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt__std__string__gt__", (PyObject *) &Pystd__vector__lt__std__string__gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt__std__string__gt__Iter", (PyObject *) &Pystd__vector__lt__std__string__gt__Iter_Type);
    PyModule_AddIntConstant(m, (char *) "kTypeInt8", bamboo::kTypeInt8);
    PyModule_AddIntConstant(m, (char *) "kTypeInt16", bamboo::kTypeInt16);
    PyModule_AddIntConstant(m, (char *) "kTypeInt32", bamboo::kTypeInt32);
    PyModule_AddIntConstant(m, (char *) "kTypeInt64", bamboo::kTypeInt64);
    PyModule_AddIntConstant(m, (char *) "kTypeUint8", bamboo::kTypeUint8);
    PyModule_AddIntConstant(m, (char *) "kTypeUint16", bamboo::kTypeUint16);
    PyModule_AddIntConstant(m, (char *) "kTypeUint32", bamboo::kTypeUint32);
    PyModule_AddIntConstant(m, (char *) "kTypeUint64", bamboo::kTypeUint64);
    PyModule_AddIntConstant(m, (char *) "kTypeChar", bamboo::kTypeChar);
    PyModule_AddIntConstant(m, (char *) "kTypeFloat32", bamboo::kTypeFloat32);
    PyModule_AddIntConstant(m, (char *) "kTypeFloat64", bamboo::kTypeFloat64);
    PyModule_AddIntConstant(m, (char *) "kTypeString", bamboo::kTypeString);
    PyModule_AddIntConstant(m, (char *) "kTypeVarstring", bamboo::kTypeVarstring);
    PyModule_AddIntConstant(m, (char *) "kTypeBlob", bamboo::kTypeBlob);
    PyModule_AddIntConstant(m, (char *) "kTypeVarblob", bamboo::kTypeVarblob);
    PyModule_AddIntConstant(m, (char *) "kTypeStruct", bamboo::kTypeStruct);
    PyModule_AddIntConstant(m, (char *) "kTypeMethod", bamboo::kTypeMethod);
    PyModule_AddIntConstant(m, (char *) "kTypeInvalid", bamboo::kTypeInvalid);
    {
        PyObject *tmp_value;
         // bamboo::Number::kNan
        tmp_value = PyLong_FromLong(bamboo::Number::kNan);
        PyDict_SetItemString((PyObject*) PyBambooNumber_Type.tp_dict, "kNan", tmp_value);
        Py_DECREF(tmp_value);
         // bamboo::Number::kInt
        tmp_value = PyLong_FromLong(bamboo::Number::kInt);
        PyDict_SetItemString((PyObject*) PyBambooNumber_Type.tp_dict, "kInt", tmp_value);
        Py_DECREF(tmp_value);
         // bamboo::Number::kUint
        tmp_value = PyLong_FromLong(bamboo::Number::kUint);
        PyDict_SetItemString((PyObject*) PyBambooNumber_Type.tp_dict, "kUint", tmp_value);
        Py_DECREF(tmp_value);
         // bamboo::Number::kFloat
        tmp_value = PyLong_FromLong(bamboo::Number::kFloat);
        PyDict_SetItemString((PyObject*) PyBambooNumber_Type.tp_dict, "kFloat", tmp_value);
        Py_DECREF(tmp_value);
    }
    return m;
}
static PyMethodDef bamboo_traits_functions[] = {
    {NULL, NULL, 0, NULL}
};
#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_traits_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo.traits",
    NULL,
    -1,
    bamboo_traits_functions,
};
#endif

static PyObject *
initbamboo_traits(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_traits_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo.traits", bamboo_traits_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    return m;
}
/* --- module functions --- */


PyObject *
_wrap_bamboo_dcfile_parseDCValue(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *formattedValue;
    Py_ssize_t formattedValue_len;
    std::string formattedValue_std;
    bool isError;
    PyObject *py_isError;
    const char *keywords[] = {"type", "formattedValue", "isError", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#O", (char **) keywords, &PyBambooDistributedType_Type, &type, &formattedValue, &formattedValue_len, &py_isError)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    formattedValue_std = std::string(formattedValue, formattedValue_len);
    isError = PyObject_IsTrue(py_isError);
    bamboo::Buffer retval = bamboo::parse_dcvalue(type_ptr, formattedValue_std, isError);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_parseDCValue(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_bamboo_dcfile_parse_dcvalue(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyBambooDistributedType *type;
    bamboo::DistributedType *type_ptr;
    const char *formattedValue;
    Py_ssize_t formattedValue_len;
    std::string formattedValue_std;
    bool isError;
    PyObject *py_isError;
    const char *keywords[] = {"type", "formattedValue", "isError", NULL};
    PyBambooBuffer *py_Buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#O", (char **) keywords, &PyBambooDistributedType_Type, &type, &formattedValue, &formattedValue_len, &py_isError)) {
        return NULL;
    }
    type_ptr = (type ? type->obj : NULL);
    formattedValue_std = std::string(formattedValue, formattedValue_len);
    isError = PyObject_IsTrue(py_isError);
    bamboo::Buffer retval = bamboo::parse_dcvalue(type_ptr, formattedValue_std, isError);
    py_Buffer = PyObject_New(PyBambooBuffer, &PyBambooBuffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new bamboo::Buffer(retval);
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_parse_dcvalue(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_bamboo_dcfile_readDCFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    const char *filename;
    Py_ssize_t filename_len;
    std::string filename_std;
    const char *keywords[] = {"filename", NULL};
    PyBambooModule *py_Module;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &filename, &filename_len)) {
        return NULL;
    }
    filename_std = std::string(filename, filename_len);
    retval = bamboo::read_dcfile(filename_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_readDCFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_bamboo_dcfile_parse_dcfile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooModule *module;
    bamboo::Module *module_ptr;
    const char *filename;
    Py_ssize_t filename_len;
    std::string filename_std;
    const char *keywords[] = {"module", "filename", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooModule_Type, &module, &filename, &filename_len)) {
        return NULL;
    }
    module_ptr = (module ? module->obj : NULL);
    filename_std = std::string(filename, filename_len);
    retval = bamboo::parse_dcfile(module_ptr, filename_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_parse_dcfile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_bamboo_dcfile_parseDCFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyBambooModule *module;
    bamboo::Module *module_ptr;
    const char *filename;
    Py_ssize_t filename_len;
    std::string filename_std;
    const char *keywords[] = {"module", "filename", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyBambooModule_Type, &module, &filename, &filename_len)) {
        return NULL;
    }
    module_ptr = (module ? module->obj : NULL);
    filename_std = std::string(filename, filename_len);
    retval = bamboo::parse_dcfile(module_ptr, filename_std);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_parseDCFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_bamboo_dcfile_read_dcfile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bamboo::Module *retval;
    const char *filename;
    Py_ssize_t filename_len;
    std::string filename_std;
    const char *keywords[] = {"filename", NULL};
    PyBambooModule *py_Module;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &filename, &filename_len)) {
        return NULL;
    }
    filename_std = std::string(filename, filename_len);
    retval = bamboo::read_dcfile(filename_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_Module = PyObject_New(PyBambooModule, &PyBambooModule_Type);
    py_Module->obj = new bamboo::Module((*retval));
    py_Module->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_Module);
    return py_retval;
}
PyObject * _wrap_bamboo_dcfile_read_dcfile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);

static PyMethodDef bamboo_dcfile_functions[] = {
    {(char *) "parseDCValue", (PyCFunction) _wrap_bamboo_dcfile_parseDCValue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "parse_dcvalue", (PyCFunction) _wrap_bamboo_dcfile_parse_dcvalue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "readDCFile", (PyCFunction) _wrap_bamboo_dcfile_readDCFile, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "parse_dcfile", (PyCFunction) _wrap_bamboo_dcfile_parse_dcfile, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "parseDCFile", (PyCFunction) _wrap_bamboo_dcfile_parseDCFile, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "read_dcfile", (PyCFunction) _wrap_bamboo_dcfile_read_dcfile, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_dcfile_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo.dcfile",
    NULL,
    -1,
    bamboo_dcfile_functions,
};
#endif

static PyObject *
initbamboo_dcfile(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_dcfile_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo.dcfile", bamboo_dcfile_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    return m;
}
static PyMethodDef bamboo_wire_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */



static int
_wrap_PyBambooDatagram__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Datagram' cannot be constructed ()");
    return -1;
}

static PyMethodDef PyBambooDatagram_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooDatagram__tp_dealloc(PyBambooDatagram *self)
{
        bamboo::Datagram *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooDatagram__tp_richcompare (PyBambooDatagram *PYBINDGEN_UNUSED(self), PyBambooDatagram *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooDatagram_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooDatagram_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.wire.Datagram",            /* tp_name */
    sizeof(PyBambooDatagram),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooDatagram__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooDatagram__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooDatagram_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooDatagram__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyBambooDatagramIterator__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'DatagramIterator' cannot be constructed ()");
    return -1;
}

static PyMethodDef PyBambooDatagramIterator_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyBambooDatagramIterator__tp_dealloc(PyBambooDatagramIterator *self)
{
        bamboo::DatagramIterator *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyBambooDatagramIterator__tp_richcompare (PyBambooDatagramIterator *PYBINDGEN_UNUSED(self), PyBambooDatagramIterator *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyBambooDatagramIterator_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyBambooDatagramIterator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "bamboo.wire.DatagramIterator",            /* tp_name */
    sizeof(PyBambooDatagramIterator),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyBambooDatagramIterator__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyBambooDatagramIterator__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyBambooDatagramIterator_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyBambooDatagramIterator__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_wire_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo.wire",
    NULL,
    -1,
    bamboo_wire_functions,
};
#endif

static PyObject *
initbamboo_wire(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_wire_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo.wire", bamboo_wire_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    /* Register the 'bamboo::Datagram' class */
    if (PyType_Ready(&PyBambooDatagram_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "Datagram", (PyObject *) &PyBambooDatagram_Type);
    /* Register the 'bamboo::DatagramIterator' class */
    if (PyType_Ready(&PyBambooDatagramIterator_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "DatagramIterator", (PyObject *) &PyBambooDatagramIterator_Type);
    return m;
}
static PyMethodDef bamboo_functions[] = {
    {NULL, NULL, 0, NULL}
};
#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef bamboo_moduledef = {
    PyModuleDef_HEAD_INIT,
    "bamboo",
    NULL,
    -1,
    bamboo_functions,
};
#endif


#if PY_VERSION_HEX >= 0x03000000
    #define MOD_ERROR NULL
    #define MOD_INIT(name) PyObject* PyInit_##name(void)
    #define MOD_RETURN(val) val
#else
    #define MOD_ERROR
    #define MOD_INIT(name) void init##name(void)
    #define MOD_RETURN(val)
#endif
#if defined(__cplusplus)
extern "C"
#endif
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif


MOD_INIT(bamboo)
{
    PyObject *m;
    PyObject *submodule;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&bamboo_moduledef);
    #else
    m = Py_InitModule3((char *) "bamboo", bamboo_functions, NULL);
    #endif
    if (m == NULL) {
        return MOD_ERROR;
    }
    submodule = initbamboo_bits();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "bits", submodule);
    submodule = initbamboo_module();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "module", submodule);
    submodule = initbamboo_traits();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "traits", submodule);
    submodule = initbamboo_dcfile();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "dcfile", submodule);
    submodule = initbamboo_wire();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "wire", submodule);
    return MOD_RETURN(m);
}

// Filename: parser.yxx
//

%{
	#include "lex.h"
	#include "parse.h"

	#include <unistd.h>
	#include <stdint.h> // for fixed-width integer limits
	#include <math.h>   // for float-macro INFINITY
	#include <stack>    // std::stack
	#include <fstream>  // std::ifstream
	#include <sstream>  // std::stringstream

	#include "dcfile/token.h"
	#include "dcfile/parser-defs.h"
	#include "dcfile/write.h"           // format_type(Subtype);
	#include "module/Module.h"
	#include "module/DistributedType.h"
	#include "module/NumericRange.h"
	#include "module/NumericType.h"
	#include "module/ArrayType.h"
	#include "module/Struct.h"
	#include "module/Class.h"
	#include "module/Field.h"
	#include "module/Method.h"
	#include "module/Parameter.h"
	#include "module/MolecularField.h"
	#include "traits/buffers.h"

	#define yylex dclex
	#define yyparse dcparse
	#define yyerror dcerror
	#define yywarning dcwarning
	#define yychar dcyychar
	#define yydebug dcyydebug
	#define yynerrs dcyynerrs

	// Because our token type contains objects of type string, which
	// require correct copy construction (and not simply memcpying), we
	// cannot use bison's built-in autTo-stack-grow feature.  As an easy
	// solution, we ensure here that we have enough yacc stack to start
	// with, and that it doesn't ever try to grow.
	#define YYINITDEPTH 1000
	#define YYMAXDEPTH 1000

	using namespace std;
	namespace bamboo   // open namespace bamboo
	{


	// Parser output
	static Module* parsed_module = nullptr;
	static vector<uint8_t>* parsed_value = nullptr;

	// Parser state
	static Class* current_class = nullptr;
	static Struct* current_struct = nullptr;

	// Stack of distributed types for parsing values
	struct TypeAndDepth
	{
		int depth;
		const DistributedType* type;
		TypeAndDepth(const DistributedType* t, int d) : depth(d), type(t) {}
	};
	static stack<TypeAndDepth> type_stack;
	static int current_depth;

	// These two types are really common types the parser doesn't need to make new
	//     duplicates of every time a string or blob is used.
	static ArrayType* basic_string = nullptr;
	static ArrayType* basic_blob = nullptr;

	/* Helper functions */
	static bool check_depth();
	static void depth_error(string what);
	static void depth_error(int depth, string what);
	static vector<uint8_t> number_value(Subtype type, double &number);
	static vector<uint8_t> number_value(Subtype type, int64_t &number);
	static vector<uint8_t> number_value(Subtype type, uint64_t &number);

////////////////////////////////////////////////////////////////////
// Defining the interface to the parser.
////////////////////////////////////////////////////////////////////

	static void dcparser_init_file(istream& in, const string& filename, Module& module)
	{
		dclexer_init(in, filename, START_DC_FILE);
		parsed_module = &module;
	}

	static void dcparser_init_value(istream& in, const string& source,
	                           const DistributedType* type, vector<uint8_t>& output)
	{
		parsed_value = &output;
		current_depth = 0;
		type_stack.push(TypeAndDepth(type, 0));
		dclexer_init(in, source, START_DC_VALUE);
	}

	static void dcparser_cleanup()
	{
		current_depth = 0;
		type_stack = stack<TypeAndDepth>();
		parsed_module = nullptr;
		parsed_value = nullptr;
	}

%}

// Use verbose errors
%error-verbose
%debug

/* Value tokens */
%token <uint64> UNSIGNED_INTEGER
%token <real> REAL
%token <str> STRING HEX_STRING IDENTIFIER CHAR

/* Initial Tokens */
// These special tokens are used to set the starting state of the parser.
//     The lexer places the appropriate one of these on the head of the input stream.
%token START_DC_FILE
%token START_DC_VALUE

/* Define keywords */
// Declaration Keywords
%token KW_DCLASS
%token KW_STRUCT
%token KW_FROM
%token KW_IMPORT
%token KW_TYPEDEF
%token KW_KEYWORD

// Subtype Keywords
%token KW_INT8
%token KW_INT16
%token KW_INT32
%token KW_INT64
%token KW_UINT8
%token KW_UINT16
%token KW_UINT32
%token KW_UINT64
%token KW_FLOAT32
%token KW_FLOAT64
%token KW_STRING
%token KW_BLOB
%token KW_CHAR


/* Abstract Nonterminals */
%type <dfield> named_field
%type <dfield> unnamed_field
%type <dparam> parameter
%type <dmethod> method
%type <dmolecule> molecular
%type <strings> import_symbols
%type <str> import_module
%type <nametype> typedef

/* Simple Nonterminals */
%type <dfield> class_field
%type <dfield> struct_field
%type <dfield> defined_field
%type <dclass> defined_class
%type <dtype> defined_type
%type <dtype> builtin_array_type
%type <dnumeric> numeric_type
%type <subtype> array_type_token
%type <subtype> numeric_type_token
%type <int64> signed_integer
%type <uint32> small_unsigned_integer
%type <uint32> char_or_uint
%type <real> char_or_number
%type <real> number
%type <range> numeric_range
%type <range> array_range
%type <strings> keyword_list
%type <strings> import_symbol_list
%type <str> import_alternatives
// Note: These value non-terminals are obvious/simple in the grammar but have complex actions
%type <buffer> type_value
%type <buffer> array_value
%type <buffer> element_values
%type <buffer> method_value
%type <buffer> parameter_values
%type <buffer> struct_value
%type <buffer> field_values
%type <buffer> array_expansion

/* Complex Nonterminals */
// These nonterminals are not-quite-obvious/kinda-hacky, but were made to statisfy a LALR-grammar.
%type <nametype> typedef_type
%type <nametype> nonmethod_type_with_name
%type <dfield> field_with_name
%type <dfield> field_with_name_as_array
%type <dfield> field_with_name_and_default
%type <dfield> method_as_field
%type <dtype> nonmethod_type
%type <dtype> nonmethod_type_no_array
%type <dtype> type_with_array
%type <dnumeric> numeric_token_only
%type <dnumeric> numeric_with_range
%type <dnumeric> numeric_with_modulus
%type <dnumeric> numeric_with_divisor
%type <dmethod> method_body
%type <dparam> param_with_name
%type <dparam> param_with_name_as_array
%type <dparam> param_with_name_and_default

%%

grammar
	: START_DC_FILE file
	| START_DC_VALUE value
	;


file
	: empty
	| file ';'
	| file dclass
	| file dstruct
	| file import
	| file typedef
	| file keyword_decl
	;

value
	: empty
	{
		parsed_value->clear();
	}
	| type_value
	{
		parsed_value->assign($1.begin(), $1.end());
		if(!type_stack.empty()) depth_error(0, "type");
	}
	| method_value
	{
		parsed_value->assign($1.begin(), $1.end());
		if(!type_stack.empty()) depth_error(0, "method");
	}
	;

import
	: KW_IMPORT import_module
	{
		Import* import = new Import($2);
		parsed_module->add_import(import);
	}
	| KW_FROM import_module KW_IMPORT import_symbols
	{
		Import* import = new Import($2);
		import->symbols.assign($4.begin(), $4.end());
		parsed_module->add_import(import);
	}
	;

import_module
	: import_alternatives { $$ = $1; }
	| import_module '.' import_alternatives
	{
		$$ = $1 + string(".") + $3;
	}
	;

import_symbols
	: import_symbol_list { $$ = $1; }
	| '*'
	{
		$$ = vector<string>();
	}
	;

import_symbol_list
	: import_alternatives
	{
		$$ = vector<string>(1, $1);
	}
	| import_symbol_list ',' import_alternatives
	{
		$1.push_back($3);
		$$ = $1;
	}
	;

import_alternatives
	: IDENTIFIER { $$ = $1; }
	| import_alternatives '/' IDENTIFIER
	{
		$$ = $1 + string("/") + $3;
	}
	;

typedef
	: typedef_type
	{
		if($1.type == nullptr)
		{
			// Ignore this typedef, it should have already produced an error
			break;
		}

		// Set the type's typedef
		$1.type->set_alias($1.name);

		bool type_added	= parsed_module->add_typedef($1.name, $1.type);
		if(!type_added)
		{
			// Lets be really descriptive about why this failed
			DistributedType* dtype = parsed_module->get_type_by_name($1.name);
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding typedef to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

typedef_type
	: KW_TYPEDEF nonmethod_type_with_name
	{
		$$ = $2;
	}
	| typedef_type '[' array_range ']'
	{
		$$ = $1;
		$$.type = new ArrayType($1.type, $3);
	}
	;

nonmethod_type_with_name
	: nonmethod_type IDENTIFIER
	{
		DCToken::NameType nt;
		nt.type = $1;
		nt.name = $2;
		$$ = nt;
	}
	;

defined_type
	: IDENTIFIER
	{
		DistributedType* dtype = parsed_module->get_type_by_name($1);
		if(dtype == nullptr)
		{
			dcerror("Subtype '" + string($1) + "' has not been declared.");
			$$ = nullptr;
			break;
		}

		$$ = dtype;
	}
	;

keyword_decl
	: KW_KEYWORD keyword_decl_list
	;

keyword_decl_list
	: empty
	| keyword_decl_list IDENTIFIER
	{
		parsed_module->add_keyword($2);
	}
	;

dclass
	: KW_DCLASS IDENTIFIER
	{
		current_class = new Class(parsed_module, $2);
	}
	  class_inheritance '{' class_fields '}'
	{
		bool class_added = parsed_module->add_class(current_class);
		if(!class_added)
		{
			// Lets be really descriptive about why this failed
			DistributedType* dtype = parsed_module->get_type_by_name(current_class->get_name());
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding class to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'dclass " + current_class->get_name()
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'dclass " + current_class->get_name()
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'dclass " + current_class->get_name()
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

class_inheritance
	: empty
	| ':' class_parents
	;

class_parents
	: defined_class
	{
		if($1 != nullptr)
		{
			current_class->add_parent($1);
		}
	}
	| class_parents ',' defined_class
	{
		if($3 != nullptr)
		{
			current_class->add_parent($3);
		}
	}
	;

defined_class
	: IDENTIFIER
	{
		DistributedType* dtype = parsed_module->get_type_by_name($1);
		if(dtype == nullptr)
		{
			dcerror("'dclass " + string($1) + "' has not been declared.");
			$$ = nullptr;
			break;
		}

		Struct* dstruct = dtype->as_struct();
		if(dstruct == nullptr)
		{
			dcerror("class cannot inherit from non-class type '" + string($1) + "'.");
			$$ = nullptr;
			break;
		}

		Class* dclass = dstruct->as_class();
		if(dclass == nullptr)
		{
			dcerror("class cannot inherit from struct type '" + string($1) + "'.");
			$$ = nullptr;
			break;
		}

		$$ = dclass;
	}
	;

class_fields
	: empty
	| class_fields ';'
	| class_fields class_field ';'
	{
		if($2 == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			break;
		}

		bool field_added = current_class->add_field($2);
		if(!field_added)
		{
			// Lets be really descriptive about why this failed
			if(current_class->get_field_by_name($2->get_name()))
			{
				dcerror("Cannot add field '" + $2->get_name()
				             + "', a field with that name already exists in 'dclass "
				             + current_class->get_name() + "'.");
			}
			else if(current_class->get_name() == $2->get_name())
			{
				if($2->as_molecular())
				{
					dcerror("Cannot use a molecular field as a constructor.");
				}
				else
				{
					dcerror("The constructor must be the first field in the class.");
				}
			}
			else
			{
				dcerror("Unknown error adding field to class.");
			}
		}
	}
	;

class_field
	: named_field keyword_list
	{
		if($1 == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			$$ = nullptr;
			break;
		}

		if($1->get_name().empty())
		{
			dcerror("An unnamed field can't be defined in a class.");
			$$ = nullptr;
			break;
		}

		// Add the keywords to the class
		for(auto it = $2.begin(); it != $2.end(); ++it)
		{
			$1->add_keyword(*it);
		}

		$$ = $1;
	}
	| molecular
	{
		$$ = (Field*)$1;
	}
	;

dstruct
	: KW_STRUCT IDENTIFIER
	{
		current_struct = new Struct(parsed_module, $2);
	}
	  '{' struct_fields '}'
	{
		bool struct_added = parsed_module->add_struct(current_struct);
		if(!struct_added)
		{
			// Lets be really descriptive about why this failed
			DistributedType* dtype = parsed_module->get_type_by_name(current_struct->get_name());
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding struct to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'struct " + current_struct->get_name()
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'struct " + current_struct->get_name()
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'struct " + current_struct->get_name()
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

struct_fields
	: empty
	| struct_fields ';'
	| struct_fields struct_field ';'
	{
		if($2 == nullptr || $2->get_type() == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			break;
		}

		if(!current_struct->add_field($2))
		{
			// Lets be really descriptive about why this failed
			if(current_struct->get_field_by_name($2->get_name()))
			{
				dcerror("Cannot add field '" + $2->get_name()
				             + "', a field with that name already exists in 'struct "
				             + current_struct->get_name() + "'.");
			}
			else if(current_struct->get_name() == $2->get_name())
			{
				dcerror("A constructor can't be defined in a struct.");
			}
			else if($2->get_type()->as_method())
			{
				dcerror("A method can't be defined in a struct.");
			}
			else
			{
				dcerror("Unknown error adding field to struct.");
			}
		}
	}
	;

struct_field
	: named_field
	| unnamed_field
	;

named_field
	: field_with_name
	| field_with_name_as_array
	| field_with_name_and_default
	| method_as_field
	;

unnamed_field
	: nonmethod_type
	{
		$$ = new Field($1);
	}
	| nonmethod_type '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1, 0));
	}
	  type_value
	{
		Field* field = new Field($1);
		if(!type_stack.empty()) depth_error(0, "unnamed field");
		field->set_default_value($4);
		$$ = field;
	}
	;

field_with_name
	: nonmethod_type_with_name
	{
		$$ = new Field($1.type, $1.name);
	}
	;

field_with_name_as_array
	: field_with_name '[' array_range ']'
	{
		$1->set_type(new ArrayType($1->get_type(), $3));
		$$ = $1;
	}
	| field_with_name_as_array '[' array_range ']'
	{
		$1->set_type(new ArrayType($1->get_type(), $3));
		$$ = $1;
	}
	;

field_with_name_and_default
	: field_with_name '=' 
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->get_type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "field '" + $1->get_name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| field_with_name_as_array '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->get_type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "field '" + $1->get_name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| method_as_field '=' method_value
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->get_type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "method");
		$1->set_default_value($3);
		$$ = $1;
	}
	;

method_as_field
	: IDENTIFIER method
	{
		$$ = new Field($2, $1);
	}
	;

nonmethod_type
	: nonmethod_type_no_array
	| type_with_array
	;

nonmethod_type_no_array
	: defined_type
	{
		if($1 == nullptr)
		{
			// defined_type should have output an error, pass nullptr upstream
			$$ = nullptr;
			break;
		}

		if($1->get_subtype() == kTypeMethod)
		{
			dcerror("Cannot use a method type here.");
			$$ = nullptr;
			break;
		}

		$$ = $1;
	}
	| numeric_type
	{
		$$ = (DistributedType*)$1;
	}
	| builtin_array_type
	;

type_with_array
	: numeric_type '[' array_range ']'
	{
		$$ = new ArrayType($1, $3);
	}
	| defined_type '[' array_range ']'
	{
		$$ = new ArrayType($1, $3);
	}
	| builtin_array_type '[' array_range ']'
	{
		$$ = new ArrayType($1, $3);
	}
	| type_with_array '[' array_range ']'
	{
		$$ = new ArrayType($1, $3);
	}
	;

molecular
	: IDENTIFIER ':' defined_field
	{
		MolecularField* mol = new MolecularField(current_class, $1);
		if($3 == nullptr)
		{
			// Ignore this field, it should have already generated an error
			$$ = mol;
			break;
		}

		bool field_added = mol->add_field($3);
		if(!field_added)
		{
			if($3->as_molecular())
			{
				dcerror("Cannot add molecular '" + $3->get_name() + "' to a molecular field.");
			}
			else
			{
				dcerror("Unkown error adding field " + $3->get_name() + " to molecular '"
				             + $1 + "'.");
			}
		}

		$$ = mol;
	}
	| molecular ',' defined_field
	{
		if($3 == nullptr)
		{
			// Ignore this field, it should have already generated an error
			$$ = $1;
			break;
		}

		bool field_added = $1->add_field($3);
		if(!field_added)
		{
			if($3->as_molecular())
			{
				dcerror("Cannot add molecular '" + $3->get_name() + "' to a molecular field.");
			}
			else if(!$1->has_matching_keywords(*$3))
			{
				dcerror("Mismatched keywords in molecular between " +
					$1->get_field(0)->get_name() + " and " + $3->get_name() + ".");
			}
			else
			{
				dcerror("Unkown error adding field " + $3->get_name() + " to molecular '"
				             + $1->get_name() + "'.");
			}
		}

		$$ = $1;
	}

defined_field
	: IDENTIFIER
	{
		if(!current_class)
		{
			dcerror("Field '" + $1 + "' not defined in current class.");
			$$ = nullptr;
			break;
		}

		Field *field = current_class->get_field_by_name($1);
		if(field == nullptr)
		{
			dcerror("Field '" + $1 + "' not defined in current class.");
			$$ = nullptr;
			break;
		}

		$$ = field;
	}
	;

builtin_array_type
	: array_type_token
	{
		if($1 == kTypeString)
		{
			if(basic_string == nullptr)
			{
				basic_string = new ArrayType(new NumericType(kTypeChar));
				basic_string->set_alias("string");
			}

			$$ = basic_string;
		}
		else if($1 == kTypeBlob)
		{
			if(basic_blob == nullptr)
			{
				basic_blob = new ArrayType(new NumericType(kTypeUint8));
				basic_blob->set_alias("blob");
			}

			$$ = basic_blob;
		}
		else
		{
			dcerror("Found builtin ArrayType not handled by parser.");
			$$ = nullptr;
		}
	}
	| array_type_token '(' array_range ')'
	{
		if($1 == kTypeString)
		{
			ArrayType* arr = new ArrayType(new NumericType(kTypeChar), $3);
			arr->set_alias("string");
			$$ = arr;
		}
		else if($1 == kTypeBlob)
		{
			ArrayType* arr = new ArrayType(new NumericType(kTypeUint8), $3);
			arr->set_alias("blob");
			$$ = arr;
		}
		else
		{
			dcerror("Found builtin ArrayType not handled by parser.");
			$$ = nullptr;
		}
	}
	;

numeric_type
	: numeric_token_only
	| numeric_with_modulus
	| numeric_with_divisor
	| numeric_with_range
	;

numeric_token_only
	: numeric_type_token { $$ = new NumericType($1); }
	;

numeric_with_range
	: numeric_token_only '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	| numeric_with_modulus '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	| numeric_with_divisor '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	;

numeric_with_modulus
	: numeric_token_only '%' number
	{
		if(!$1->set_modulus($3))
		{
			dcerror("Invalid modulus for type.");
		}

		$$ = $1;
	}
	;

numeric_with_divisor
	: numeric_token_only '/' small_unsigned_integer
	{
		if(!$1->set_divisor($3))
		{
			dcerror("Invalid divisor for type.");
		}
	}
	| numeric_with_modulus '/' small_unsigned_integer
	{
		if(!$1->set_divisor($3))
		{
			dcerror("Invalid divisor for type.");
		}
	}
	;

method
	: '(' ')'
	{
		$$ = new Method();
	}
	| method_body ')'
	{
		$$ = $1;
	}
	;

method_body
	: '(' parameter
	{
		Method* fn = new Method();
		bool param_added = fn->add_parameter($2);
		if(!param_added)
		{
			dcerror("Unknown error adding parameter to method.");
		}
		$$ = fn;
	}
	| method_body ',' parameter
	{
		bool param_added = $1->add_parameter($3);
		if(!param_added)
		{
			dcerror("Cannot add parameter '" + $3->get_name()
			             + "', a parameter with that name is already used in this method.");
		}
		$$ = $1;
	}
	;

parameter
	: param_with_name
	| param_with_name_as_array
	| param_with_name_and_default
	| nonmethod_type
	{
		$$ = new Parameter($1);
	}
	| nonmethod_type '=' 
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1,0));
	}
	  type_value
	{
		Parameter* param = new Parameter($1);
		if(!type_stack.empty()) depth_error(0, "type");
		param->set_default_value($4);
		$$ = param;
	}

param_with_name
	: nonmethod_type_no_array IDENTIFIER
	{
		$$ = new Parameter($1, $2);
	}
	;

param_with_name_as_array
	: param_with_name '[' array_range ']'
	{
		$1->set_type(new ArrayType($1->get_type(), $3));
		$$ = $1;
	}
	| param_with_name_as_array '[' array_range ']'
	{
		$1->set_type(new ArrayType($1->get_type(), $3));
		$$ = $1;
	}
	;

param_with_name_and_default
	: param_with_name '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->get_type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "parameter '" + $1->get_name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| param_with_name_as_array '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->get_type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "parameter '" + $1->get_name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	;

numeric_range
	: empty { $$ = NumericRange(); }
	| char_or_number { $$ = NumericRange($1, $1); }
	| char_or_number '-' char_or_number { $$ = NumericRange($1, $3); }
	;

array_range
	: empty { $$ = NumericRange(); }
	| char_or_uint { $$ = NumericRange($1, $1); }
	| char_or_uint '-' char_or_uint { $$ = NumericRange($1, $3); }
	;

char_or_uint
	: CHAR
	{
		if($1.length() != 1)
		{
			dcerror("Single character required.");
			$$ = 0;
		}
		else
		{
			$$ = (unsigned char)$1[0];
		}
	}
	| small_unsigned_integer
	;

small_unsigned_integer
	: UNSIGNED_INTEGER
	{
		unsigned int num = (unsigned int)$1;
		if(num != $1)
		{
			dcerror("Number out of range.");
			$$ = 1;
		}
		$$ = num;
	}
	;

number
	: UNSIGNED_INTEGER { $$ = (double)$1; }
	| signed_integer { $$ = (double)$1; }
	| REAL
	;

char_or_number
	: CHAR
	{
		if($1.length() != 1) {
			dcerror("Single character required.");
			$$ = 0;
		} else {
			$$ = (double)(unsigned char)$1[0];
		}
	}
	| number
	;

type_value
	: signed_integer
	{
		if(!check_depth()) depth_error("signed integer");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype->get_subtype(), $1);
	}
	| UNSIGNED_INTEGER
	{
		if(!check_depth()) depth_error("unsigned integer");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype->get_subtype(), $1);
	}
	| REAL
	{
		if(!check_depth()) depth_error("floating point");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype->get_subtype(), $1);
	}
	| STRING
	{
		if(!check_depth()) depth_error("string");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Remove string type from stack

		if(dtype->get_subtype() == kTypeString || dtype->get_subtype() == kTypeBlob) {
			if($1.length() != dtype->get_size()) {
				dcerror("Value for fixed-length string has incorrect length.");
			}

			$$ = as_buffer($1);
		} else if(dtype->get_subtype() == kTypeVarstring || dtype->get_subtype() == kTypeVarblob) {
			// TODO: Check for range limits
			// Prepend length tag
			sizetag_t length = $1.length();
			vector<uint8_t> buf = as_buffer(length);
			pack_value($1, buf);
			$$ = buf;
		}
		else {
			dcerror("Cannot use string value for non-string type '"
			             + format_type(dtype->get_subtype()) + "'.");
			$$ = as_buffer($1);
		}
	}
	| HEX_STRING
	{
		if(!check_depth()) depth_error("hex-string");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Remove type from stack

		if(dtype->get_subtype() == kTypeBlob) {
			if($1.length() != dtype->get_size()) {
				dcerror("Value for fixed-length blob has incorrect length.");
			}

			$$ = as_buffer($1);
		} else if(dtype->get_subtype() == kTypeVarblob) {
			// TODO: Check for range limits
			$$ = as_buffer($1);
		} else {
			dcerror("Cannot use hex value for non-blob type '"
			             + format_type(dtype->get_subtype()) + "'.");
			$$ = as_buffer($1);
		}
	}
	| array_value
	| struct_value
	;

method_value
	: '('
	{
		if(!check_depth()) depth_error("method");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_method()) {
			current_depth++;
			const Method* method = dtype->as_method();

			size_t num_params = method->get_num_parameters();
			for(unsigned int i = 1; i <= num_params; ++i) {
				// Reverse iteration
				const Parameter* param = method->get_parameter(num_params-i);
				// Add parameter types to stack such that the first is on top
				type_stack.push(TypeAndDepth(param->get_type(), current_depth));
			}
		} else {
			dcerror("Cannot use method-value for non-method type '"
			             + format_type(dtype->get_subtype()) + "'.");
		}
	}
	  parameter_values ')'
	{
		if(type_stack.top().type->as_method()) {
			current_depth--;
		}
		type_stack.pop(); // Remove method type from the stack
		$$ = $3;
	}
	;

parameter_values
	: type_value
	| parameter_values ',' type_value
	{
		vector<uint8_t> buf = $1;
		pack_value($3, buf);
		$$ = buf;
	}
	;

struct_value
	: '{'
	{
		if(!check_depth()) depth_error("struct");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_struct()) {
			current_depth++;
			const Struct* dstruct = dtype->as_struct();

			size_t num_fields = dstruct->get_num_fields();
			for(unsigned int i = 1; i <= num_fields; ++i) {
				// Reverse iteration
				const Field* field = dstruct->get_field(num_fields-i);
				// Add field types to stack such that the first is on top
				type_stack.push(TypeAndDepth(field->get_type(), current_depth));
			}
		} else {
			dcerror("Cannot use struct-composition for non-struct type '"
			             + format_type(dtype->get_subtype()) + "'.");
		}
	}
	  field_values '}'
	{
		if(type_stack.top().type->as_struct()) {
			current_depth--;
		}
		type_stack.pop(); // Remove method type from the stack
		$$ = $3;
	}
	;

field_values
	: type_value
	| method_value
	| field_values ',' type_value
	{
		vector<uint8_t> buf = $1;
		pack_value($3, buf);
		$$ = buf;
	}
	| field_values ',' method_value
	{
		vector<uint8_t> buf = $1;
		pack_value($3, buf);
		$$ = buf;
	}
	;

array_value
	: '[' ']' // empty array
	{
		if(!check_depth()) depth_error("array");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();;
			break;
		}
		type_stack.pop();
		if(!dtype->as_array()) {
			dcerror("Cannot use array-composition for non-array type '"
			             + format_type(dtype->get_subtype()) + "'.");
			$$ = vector<uint8_t>();;
			break;
		}
		const ArrayType* array = dtype->as_array();

		if(array->get_array_size() > 0) {
			// For fixed size arrays, an empty array is an error
			dcerror("Fixed-sized array of size "
			             + to_string(array->get_array_size())
			             + " can't have 0 elements.");
		} else if(array->has_range()) {
			// If we have a range, 0 elements must be valid in the range
			if(0 < array->get_range().min.uinteger) {
				dcerror("Too few elements in array value, minimum "
				             + to_string(array->get_range().min.uinteger) + ".");
			}
		}

		// Since a fixed-size array can't have zero elements, this always
		// the default value for a varsize array, which is the length-tag 0.
		$$ = vector<uint8_t>(sizeof(sizetag_t), 0);
	}
	| '['
	{
		if(!check_depth()) depth_error("array");

		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_array()) {
			const ArrayType* array = dtype->as_array();

			// For arrays we're going to do something pretty hacky:
			//    For every element we had we are going to increment the depth,
			//    and after we finish the element_values production we will compare
			//    the current_depth to the depth of our original symbol to check
			//    if the array size is proper.
			type_stack.push(TypeAndDepth(array->get_element_type(), current_depth));
		} else {
			dcerror("Cannot use array-composition for non-array type '"
			             + format_type(dtype->get_subtype()) + "'.");
		}
	}
	  element_values ']'
	{
		if(type_stack.top().type->as_array()) {
			uint64_t actual_size = current_depth - type_stack.top().depth;

			const DistributedType* dtype = type_stack.top().type;
			if(dtype == nullptr) {
				// Ignore this field, it should have already generated an error
				$$ = vector<uint8_t>();
				break;
			}

			const ArrayType* array = dtype->as_array();
			if(array->has_range()) {
				if(actual_size > array->get_range().max.uinteger) {
					dcerror("Too many elements in array value, maximum "
					             + to_string(array->get_range().max.uinteger) + ".");
				} else if(actual_size < array->get_range().min.uinteger) {
					dcerror("Too few elements in array value, minimum "
					             + to_string(array->get_range().min.uinteger) + ".");
				}
			}

			if(array->get_array_size() == 0) {
				vector<uint8_t> buf = as_buffer(sizetag_t($3.size()));
				pack_value($3, buf);
				$$ = buf;
			} else {
				$$ = $3;
			}
			current_depth = type_stack.top().depth;
		}

		type_stack.pop(); // Remove array type from the stack
	}
	;

element_values
	: array_expansion
	| element_values ',' 
	{
		// We popped off the only element we added, so we're back to the array
		// Don't increment the depth; the array_expansion will add to
		// the current_depth depending on the number of elements it adds.
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}
		const ArrayType* array = dtype->as_array();
		type_stack.push(TypeAndDepth(array->get_element_type(), current_depth));
	}
	  array_expansion
	{
		// $4 packed onto end of $1
		std::vector<uint8_t> buf = $1;
		pack_value($4, buf);
		$$ = buf;
	}
	;

array_expansion
	: type_value
	{
		current_depth++;
		$$ = $1;
	}
	| signed_integer '*' small_unsigned_integer
	{
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> base = number_value(dtype->get_subtype(), $1);
		buf.reserve(base.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(base, buf);
		}
		$$ = buf;
	}
	| UNSIGNED_INTEGER '*' small_unsigned_integer
	{
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> base = number_value(dtype->get_subtype(), $1);
		buf.reserve(base.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(base, buf);
		}
		$$ = buf;
	}
	| REAL '*' small_unsigned_integer
	{
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> base = number_value(dtype->get_subtype(), $1);
		buf.reserve(base.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(base, buf);
		}
		$$ = buf;
	}
	| STRING '*' small_unsigned_integer
	{
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		if(dtype->get_subtype() == kTypeString) {
			if($1.length() != dtype->get_size()) {
				dcerror("Value for fixed-length string has incorrect length.");
			}

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		} else if(dtype->get_subtype() == kTypeVarstring) {
			// Prepend length tag
			vector<uint8_t> buf = as_buffer($1.length());
			vector<uint8_t> base = as_buffer($1);
			buf.reserve(base.size() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value(base, buf);
			}
			$$ = buf;

			// TODO: Check for range limits

		} else {
			dcerror("Cannot use string value for non-string type '"
			             + format_type(dtype->get_subtype()) + "'.");

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		}
	}
	| HEX_STRING '*' small_unsigned_integer
	{
		const DistributedType* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		if(dtype->get_subtype() == kTypeBlob) {
			if($1.length() != dtype->get_size()) {
				dcerror("Value for fixed-length blob has incorrect length.");
			}

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		} else if(dtype->get_subtype() == kTypeVarblob) {
			// Prepend length tag
			vector<uint8_t> buf = as_buffer($1.length());
			vector<uint8_t> base = as_buffer($1);
			buf.reserve(base.size() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value(base, buf);
			}
			$$ = buf;

			// TODO: Check for range limits

		} else {
			dcerror("Cannot use hex value for non-blob type '"
			             + format_type(dtype->get_subtype()) + "'.");

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		}
	}
	;

signed_integer
	: '+' UNSIGNED_INTEGER { $$ = $2; }
	| '-' UNSIGNED_INTEGER { $$ = -$2; }
	;

array_type_token
	: KW_STRING { $$ = kTypeString; }
	| KW_BLOB { $$ = kTypeBlob; }
	;

numeric_type_token
	: KW_CHAR { $$ = kTypeChar; }
	| KW_INT8 { $$ = kTypeInt8; }
	| KW_INT16 { $$ = kTypeInt16; }
	| KW_INT32 { $$ = kTypeInt32; }
	| KW_INT64 { $$ = kTypeInt64; }
	| KW_UINT8 { $$ = kTypeUint8; }
	| KW_UINT16 { $$ = kTypeUint16; }
	| KW_UINT32 { $$ = kTypeUint32; }
	| KW_UINT64 { $$ = kTypeUint64; }
	| KW_FLOAT32 { $$ = kTypeFloat32; }
	| KW_FLOAT64 { $$ = kTypeFloat64; }
	;

keyword_list
	: empty
	{
		$$ = vector<string>();
	}
	| keyword_list IDENTIFIER
	{
		if(!parsed_module->has_keyword($2))
		{
			dcerror("Keyword '" + $2 + "' has not been declared.");
			break;
		}

		$1.push_back($2);
		$$ = $1;
	}
	;

empty
	:
	;

%% /* Start helper function section */


Module *read_dcfile(istream& in, const string& filename) {
    Module *m = new Module();
    bool ok = parse_dcfile(m, in, filename);
    if(ok) {
        return m;
    }

    return nullptr;
}
Module *read_dcfile(const string& filename) {
    Module *m = new Module();
    bool ok = parse_dcfile(m, filename);
    if(ok) {
        return m;
    }

    return nullptr;
}
bool parse_dcfile(Module *m, istream& in, const string& filename) {
    dcparser_init_file(in, filename, *m);
    dcparse();
    dcparser_cleanup();
    return (dc_errors() == 0);
}
bool parse_dcfile(Module *m, const string& filename) {
    ifstream in;
    in.open(filename.c_str());
    if(!in) {
        cerr << "Cannot open " << filename << " for reading.\n";
        return false;
    }
    return parse_dcfile(m, in, filename);
}
vector<uint8_t> parse_dcvalue(const DistributedType *dtype, const string& formatted, bool& err) {
    istringstream strm(formatted);
    return parse_dcvalue(dtype, strm, err);

}
vector<uint8_t> parse_dcvalue(const DistributedType *dtype, istream& in, bool& err) {
    vector<uint8_t> value;
    try {
        dcparser_init_value(in, "parse_value()", dtype, value);
        dcparse();
        dcparser_cleanup();
    } catch(const exception& e) {
        err = true;
        return vector<uint8_t>();
    }

    if(dc_errors() > 0) {
        err = true;
        return vector<uint8_t>();
    }

    err = false;
    return value;
}


bool check_depth()
{
	return (!type_stack.empty() && current_depth == type_stack.top().depth);
}

void depth_error(string what)
{
	if(type_stack.empty() || current_depth < type_stack.top().depth) {
		dcerror("Too many nested values while parsing value for " + what + ".");
	} else {
		dcerror("Too few nested values while parsing value for " + what + ".");	
	}
}

void depth_error(int depth, string what)
{
	if(current_depth > depth) {
		dcerror("Too few nested values before this " + what + " value.");
	} else {
		dcerror("Too many nested values before this " + what + " value.");
	}
}

vector<uint8_t> number_value(Subtype type, double &number)
{
	switch(type) {
		case kTypeFloat32:
			if(float(number) == INFINITY || float(number) == -INFINITY) {
				dcerror("Value is out of range for type 'float32'.");
			}
			return as_buffer(float(number));
		case kTypeFloat64:
			return as_buffer(number);
		case kTypeInt8:
		case kTypeInt16:
		case kTypeInt32:
		case kTypeInt64:
		case kTypeChar:
		case kTypeUint8:
		case kTypeUint16:
		case kTypeUint32:
		case kTypeUint64:
			dcerror("Cannot use floating-point value for integer datatype.");
			return vector<uint8_t>();
		default:
			dcerror("Cannot use floating-point value for non-numeric datatype.");
			return vector<uint8_t>();
	}
}

vector<uint8_t> number_value(Subtype type, int64_t &number)
{
	switch(type) {
		case kTypeInt8:
			if(INT8_MIN > number || number > INT8_MAX) {
				dcerror("Signed integer out of range for type 'int8'.");
			}
			return as_buffer(int8_t(number));
		case kTypeInt16:
			if(INT16_MIN > number || number > INT16_MAX) {
				dcerror("Signed integer out of range for type 'int16'.");
			}
			return as_buffer(int16_t(number));
		case kTypeInt32:
			if(INT32_MIN > number || number > INT32_MAX) {
				dcerror("Signed integer out of range for type 'int32'.");
			}
			return as_buffer(int32_t(number));
		case kTypeInt64:
			return as_buffer(number);
		case kTypeChar:
		case kTypeUint8:
		case kTypeUint16:
		case kTypeUint32:
		case kTypeUint64: {
			if(number < 0) {
				dcerror("Can't use negative value for unsigned integer datatype.");
			}
			uint64_t value = number;
			return number_value(type, value);
		}
		case kTypeFloat32:
		case kTypeFloat64: {
			// Note: Expecting number to be converted to a double by value (ie. 3 becomes 3.0)
			double value = number;
			return number_value(type, value);
		}
		default:
			dcerror("Cannot use signed integer value for non-numeric datatype.");
			return vector<uint8_t>();
	}
}

vector<uint8_t> number_value(Subtype type, uint64_t &number)
{
	switch(type)
	{
		case kTypeChar:
			if(number > UINT8_MAX) {
				dcerror("Unsigned integer out of range for type 'char'.");
			}
			return as_buffer(char(number));
		case kTypeUint8:
			if(number > UINT8_MAX) {
				dcerror("Unsigned integer out of range for type 'uint8'.");
			}
			return as_buffer(uint8_t(number));
		case kTypeUint16:
			if(number > UINT16_MAX) {
				dcerror("Unsigned integer out of range for type 'uint16'.");
			}
			return as_buffer(uint16_t(number));
		case kTypeUint32:
			if(number > UINT32_MAX) {
				dcerror("Unsigned integer out of range for type 'uint32'.");
			}
			return as_buffer(uint32_t(number));
		case kTypeUint64:
			return as_buffer(number);
		case kTypeInt8:
		case kTypeInt16:
		case kTypeInt32:
		case kTypeInt64: {
			if(number > INT64_MAX) {
				dcerror("Unsigned integer out of range for signed integer datatype.");
			}
			int64_t value = number;
			return number_value(type, value);
		}
		case kTypeFloat32:
		case kTypeFloat64: {
			// Note: Expecting number to be converted to a double by value (ie. 3 becomes 3.0)
			double value = number;
			return number_value(type, value);
		}
		default:
			dcerror("Cannot use unsigned integer value for non-numeric datatype.");
			return vector<uint8_t>();
	}
}


} // close namespace bamboo

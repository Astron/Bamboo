// Filename: parser.yxx
//

%{
	#include "lex.h"
	#include "parse.h"

	#include <cstdint>  // for fixed-width integers
	#include <cmath>    // std::isinf
	#include <stack>    // std::stack
	#include <fstream>  // std::ifstream
	#include <sstream>  // std::stringstream

	#include "../dcfile/token.h"
	#include "../dcfile/parser-defs.h"
	#include "../module/Module.h"
	#include "../module/Type.h"
	#include "../module/NumericRange.h"
	#include "../module/Numeric.h"
	#include "../module/Array.h"
	#include "../module/Struct.h"
	#include "../module/Class.h"
	#include "../module/Field.h"
	#include "../module/Method.h"
	#include "../module/Parameter.h"
	#include "../module/MolecularField.h"
	#include "../bits/buffers.h"

	//#define yylex dclex
	//#define yyparse dcparse
	//#define yyerror dcerror
	//#define yywarning dcwarning
	//#define yychar dcyychar
	//#define yydebug dcyydebug
	//#define yynerrs dcyynerrs

	// Because our token type contains objects of type string, which
	// require correct copy construction (and not simply memcpying), we
	// cannot use bison's built-in autTo-stack-grow feature.  As an easy
	// solution, we ensure here that we have enough yacc stack to start
	// with, and that it doesn't ever try to grow.
	#define YYINITDEPTH 1000
	#define YYMAXDEPTH 1000

	using namespace std;
	using namespace bamboo;
	namespace bamboo   // open namespace bamboo
	{


	// Parser output
	static Module* parsed_module = nullptr;
	static Value parsed_value;

	// Parser state
	static Class* current_class = nullptr;
	static Struct* current_struct = nullptr;

	// Stack of distributed types for parsing values
	struct TypeAndDepth
	{
		int depth;
		const Type* type;
		TypeAndDepth(const Type* t, int d) : depth(d), type(t) {}
	};
	static stack<TypeAndDepth> type_stack;
	static int current_depth;

	// These two types are really common types the parser doesn't need to make new
	//     duplicates of every time a string or blob is used.
	static Array* default_string = nullptr;
	static Array* default_blob = nullptr;

	/* Helper functions */
	static bool check_depth();
	static void depth_error(string what);
	static void depth_error(int depth, string what);
	static Value number_value(const Type *type, double &number);
	static Value number_value(const Type *type, int64_t &number);
	static Value number_value(const Type *type, uint64_t &number);

////////////////////////////////////////////////////////////////////
// Defining the interface to the parser.
////////////////////////////////////////////////////////////////////

	static void dcparser_init_file(istream& in, const string& filename, Module& module)
	{
		dclexer_init(in, filename, START_DC_FILE);
		parsed_module = &module;
	}

	static void dcparser_init_value(istream& in, const string& source, const Type* type)
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth(type, 0));
		dclexer_init(in, source, START_DC_VALUE);
	}

	static void dcparser_cleanup()
	{
		current_depth = 0;
		type_stack = stack<TypeAndDepth>();
		parsed_module = nullptr;
		parsed_value = Value();
	}


	} // close namespace bamboo
%}

// Use verbose errors
%define api.prefix {dc}
%error-verbose
%debug

/* Value tokens */
%token <uint64> UNSIGNED_INTEGER
%token <real> REAL
%token <str> STRING HEX_STRING IDENTIFIER CHAR

/* Initial Tokens */
// These special tokens are used to set the starting state of the parser.
//     The lexer places the appropriate one of these on the head of the input stream.
%token START_DC_FILE
%token START_DC_VALUE

/* Define keywords */
// Declaration Keywords
%token KW_DCLASS
%token KW_STRUCT
%token KW_FROM
%token KW_IMPORT
%token KW_TYPEDEF
%token KW_KEYWORD

// Subtype Keywords
%token KW_INT8
%token KW_INT16
%token KW_INT32
%token KW_INT64
%token KW_UINT8
%token KW_UINT16
%token KW_UINT32
%token KW_UINT64
%token KW_FLOAT32
%token KW_FLOAT64
%token KW_STRING
%token KW_BLOB
%token KW_CHAR


/* Abstract Nonterminals */
%type <dfield> named_field
%type <dfield> unnamed_field
%type <dparam> parameter
%type <dmethod> method
%type <dmolecule> molecular
%type <strings> import_symbols
%type <str> import_module
%type <nametype> typedef

/* Simple Nonterminals */
%type <dfield> class_field
%type <dfield> struct_field
%type <dfield> defined_field
%type <dclass> defined_class
%type <dtype> defined_type
%type <dtype> builtin_array_type
%type <dnumeric> numeric_type
%type <subtype> array_type_token
%type <subtype> numeric_type_token
%type <int64> signed_integer
%type <uint32> small_unsigned_integer
%type <uint32> char_or_uint
%type <real> char_or_number
%type <real> number
%type <range> numeric_range
%type <range> array_range
%type <strings> keyword_list
%type <strings> import_symbol_list
%type <str> import_alternatives
// Note: These value non-terminals are obvious/simple in the grammar but have complex actions
%type <value> type_value
%type <value> array_value
%type <value> element_values
%type <value> method_value
%type <value> parameter_values
%type <value> struct_value
%type <value> field_values
%type <value> array_expansion

/* Complex Nonterminals */
// These nonterminals are not-quite-obvious/kinda-hacky, but were made to statisfy a LALR-grammar.
%type <nametype> typedef_type
%type <nametype> nonmethod_type_with_name
%type <dfield> field_with_name
%type <dfield> field_with_name_as_array
%type <dfield> field_with_name_and_default
%type <dfield>  method_as_field
%type <dtype> nonmethod_type
%type <dtype> nonmethod_type_no_array
%type <dtype> type_with_array
%type <dnumeric> numeric_token_only
%type <dnumeric> numeric_with_range
%type <dnumeric> numeric_with_modulus
%type <dnumeric> numeric_with_divisor
%type <dmethod> method_body
%type <dparam> param_with_name
%type <dparam> param_with_name_as_array
%type <dparam> param_with_name_and_default

%%

grammar
	: START_DC_FILE file
	| START_DC_VALUE value
	;


file
	: empty
	| file ';'
	| file dclass
	| file dstruct
	| file import
	| file typedef
	| file keyword_decl
	;

value
	: empty
	{
		parsed_value = Value();
	}
	| type_value
	{
		parsed_value = $1;
		if(!type_stack.empty()) depth_error(0, "type");
	}
	| method_value
	{
		parsed_value = $1;
		if(!type_stack.empty()) depth_error(0, "method");
	}
	;

import
	: KW_IMPORT import_module
	{
		Import* import = new Import($2);
		parsed_module->add_import(unique_ptr<Import>(import));
	}
	| KW_FROM import_module KW_IMPORT import_symbols
	{
		Import* import = new Import($2);
		import->symbols.assign($4.begin(), $4.end());
		parsed_module->add_import(unique_ptr<Import>(import));
	}
	;

import_module
	: import_alternatives { $$ = $1; }
	| import_module '.' import_alternatives
	{
		$$ = $1 + string(".") + $3;
	}
	;

import_symbols
	: import_symbol_list { $$ = $1; }
	| '*'
	{
		$$ = vector<string>();
	}
	;

import_symbol_list
	: import_alternatives
	{
		$$ = vector<string>(1, $1);
	}
	| import_symbol_list ',' import_alternatives
	{
		$1.push_back($3);
		$$ = $1;
	}
	;

import_alternatives
	: IDENTIFIER { $$ = $1; }
	| import_alternatives '/' IDENTIFIER
	{
		$$ = $1 + string("/") + $3;
	}
	;

typedef
	: typedef_type
	{
		if($1.type == nullptr)
		{
			// Ignore this typedef, it should have already produced an error
			break;
		}

		// Set the type's typedef
		$1.type->set_alias($1.name);

		bool type_added	= parsed_module->add_typedef($1.name, $1.type);
		if(!type_added)
		{
			// Lets be really descriptive about why this failed
			Type* dtype = parsed_module->type_by_name($1.name);
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding typedef to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'typedef " + $1.name
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

typedef_type
	: KW_TYPEDEF nonmethod_type_with_name
	{
		$$ = $2;
	}
	| typedef_type '[' array_range ']'
	{
		$$ = $1;
		$$.type = new Array($1.type, $3);
	}
	;

nonmethod_type_with_name
	: nonmethod_type IDENTIFIER
	{
		DCToken::NameType nt;
		nt.type = $1;
		nt.name = $2;
		$$ = nt;
	}
	;

defined_type
	: IDENTIFIER
	{
		Type* dtype = parsed_module->type_by_name($1);
		if(dtype == nullptr)
		{
			dcerror("Subtype '" + string($1) + "' has not been declared.");
			$$ = nullptr;
			break;
		}

		$$ = dtype;
	}
	;

keyword_decl
	: KW_KEYWORD keyword_decl_list
	;

keyword_decl_list
	: empty
	| keyword_decl_list IDENTIFIER
	{
		parsed_module->add_keyword($2);
	}
	;

dclass
	: KW_DCLASS IDENTIFIER
	{
		current_class = new Class(parsed_module, $2);
	}
	  class_inheritance '{' class_fields '}'
	{
		bool class_added = parsed_module->add_class(unique_ptr<Class>(current_class));
		if(!class_added)
		{
			// Lets be really descriptive about why this failed
			Type* dtype = parsed_module->type_by_name(current_class->name());
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding class to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'dclass " + current_class->name()
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'dclass " + current_class->name()
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'dclass " + current_class->name()
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

class_inheritance
	: empty
	| ':' class_parents
	;

class_parents
	: defined_class
	{
		if($1 != nullptr)
		{
			current_class->add_parent($1);
		}
	}
	| class_parents ',' defined_class
	{
		if($3 != nullptr)
		{
			current_class->add_parent($3);
		}
	}
	;

defined_class
	: IDENTIFIER
	{
		Type* dtype = parsed_module->type_by_name($1);
		if(dtype == nullptr)
		{
			dcerror("'dclass " + string($1) + "' has not been declared.");
			$$ = nullptr;
			break;
		}

		Struct* dstruct = dtype->as_struct();
		if(dstruct == nullptr)
		{
			dcerror("class cannot inherit from non-class type '" + string($1) + "'.");
			$$ = nullptr;
			break;
		}

		Class* dclass = dstruct->as_class();
		if(dclass == nullptr)
		{
			dcerror("class cannot inherit from struct type '" + string($1) + "'.");
			$$ = nullptr;
			break;
		}

		$$ = dclass;
	}
	;

class_fields
	: empty
	| class_fields ';'
	| class_fields class_field ';'
	{
		if($2 == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			break;
		}

		bool field_added = current_class->add_field(unique_ptr<Field>($2));
		if(!field_added)
		{
			// Lets be really descriptive about why this failed
			if(current_class->field_by_name($2->name()))
			{
				dcerror("Cannot add field '" + $2->name()
				             + "', a field with that name already exists in 'dclass "
				             + current_class->name() + "'.");
			}
			else if(current_class->name() == $2->name())
			{
				if($2->as_molecular())
				{
					dcerror("Cannot use a molecular field as a constructor.");
				}
				else
				{
					dcerror("The constructor must be the first field in the class.");
				}
			}
			else
			{
				dcerror("Unknown error adding field to class.");
			}
		}
	}
	;

class_field
	: named_field keyword_list
	{
		if($1 == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			$$ = nullptr;
			break;
		}

		if($1->name().empty())
		{
			dcerror("An unnamed field can't be defined in a class.");
			$$ = nullptr;
			break;
		}

		// Add the keywords to the class
		for(auto it = $2.begin(); it != $2.end(); ++it)
		{
			$1->add_keyword(*it);
		}

		$$ = $1;
	}
	| molecular
	{
		$$ = (Field*)$1;
	}
	;

dstruct
	: KW_STRUCT IDENTIFIER
	{
		current_struct = new Struct(parsed_module, $2);
	}
	  '{' struct_fields '}'
	{
		bool struct_added = parsed_module->add_struct(unique_ptr<Struct>(current_struct));
		if(!struct_added)
		{
			// Lets be really descriptive about why this failed
			Type* dtype = parsed_module->type_by_name(current_struct->name());
			if(dtype == nullptr)
			{
				dcerror("Unknown error adding struct to module.");
				break;
			}

			Struct* dstruct = dtype->as_struct();
			if(dstruct == nullptr)
			{
				dcerror("Cannot add 'struct " + current_struct->name()
				             + "' to module because a typedef was already declared with that name.");
				break;
			}

			if(dstruct->as_class())
			{
				dcerror("Cannot add 'struct " + current_struct->name()
				             + "' to module because a class was already declared with that name.");
			}
			else
			{
				dcerror("Cannot add 'struct " + current_struct->name()
				             + "' to module because a struct was already declared with that name.");
			}
		}
	}
	;

struct_fields
	: empty
	| struct_fields ';'
	| struct_fields struct_field ';'
	{
		if($2 == nullptr || $2->type() == nullptr)
		{
			// Ignore this field, it should have already generated a parser error
			break;
		}

		if(!current_struct->add_field(unique_ptr<Field>($2)))
		{
			// Lets be really descriptive about why this failed
			if(current_struct->field_by_name($2->name()))
			{
				dcerror("Cannot add field '" + $2->name()
				             + "', a field with that name already exists in 'struct "
				             + current_struct->name() + "'.");
			}
			else if(current_struct->name() == $2->name())
			{
				dcerror("A constructor can't be defined in a struct.");
			}
			else if($2->type()->as_method())
			{
				dcerror("A method can't be defined in a struct.");
			}
			else
			{
				dcerror("Unknown error adding field to struct.");
			}
		}
	}
	;

struct_field
	: named_field
	| unnamed_field
	;

named_field
	: field_with_name
	| field_with_name_as_array
	| field_with_name_and_default
	| method_as_field
	;

unnamed_field
	: nonmethod_type
	{
		$$ = new Field($1);
	}
	| nonmethod_type '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1, 0));
	}
	  type_value
	{
		Field* field = new Field($1);
		if(!type_stack.empty()) depth_error(0, "unnamed field");
		field->set_default_value($4);
		$$ = field;
	}
	;

field_with_name
	: nonmethod_type_with_name
	{
		$$ = new Field($1.type, $1.name);
	}
	;

field_with_name_as_array
	: field_with_name '[' array_range ']'
	{
		$1->set_type(new Array($1->type(), $3));
		$$ = $1;
	}
	| field_with_name_as_array '[' array_range ']'
	{
		$1->set_type(new Array($1->type(), $3));
		$$ = $1;
	}
	;

field_with_name_and_default
	: field_with_name '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "field '" + $1->name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| field_with_name_as_array '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "field '" + $1->name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| method_as_field '=' method_value
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "method");
		$1->set_default_value($3);
		$$ = $1;
	}
	;

method_as_field
	: IDENTIFIER method
	{
		$$ = new Field($2, $1);
	}
	;

nonmethod_type
	: nonmethod_type_no_array
	| type_with_array
	;

nonmethod_type_no_array
	: defined_type
	{
		if($1 == nullptr)
		{
			// defined_type should have output an error, pass nullptr upstream
			$$ = nullptr;
			break;
		}

		if($1->subtype() == kTypeMethod)
		{
			dcerror("Cannot use a method type here.");
			$$ = nullptr;
			break;
		}

		$$ = $1;
	}
	| numeric_type
	{
		$$ = (Type*)$1;
	}
	| builtin_array_type
	;

type_with_array
	: numeric_type '[' array_range ']'
	{
		$$ = new Array($1, $3);
	}
	| defined_type '[' array_range ']'
	{
		$$ = new Array($1, $3);
	}
	| builtin_array_type '[' array_range ']'
	{
		$$ = new Array($1, $3);
	}
	| type_with_array '[' array_range ']'
	{
		$$ = new Array($1, $3);
	}
	;

molecular
	: IDENTIFIER ':' defined_field
	{
		MolecularField* mol = new MolecularField(current_class, $1);
		if($3 == nullptr)
		{
			// Ignore this field, it should have already generated an error
			$$ = mol;
			break;
		}

		bool field_added = mol->add_field($3);
		if(!field_added)
		{
			if($3->as_molecular())
			{
				dcerror("Cannot add molecular '" + $3->name() + "' to a molecular field.");
			}
			else
			{
				dcerror("Unkown error adding field " + $3->name() + " to molecular '"
				             + $1 + "'.");
			}
		}

		$$ = mol;
	}
	| molecular ',' defined_field
	{
		if($3 == nullptr)
		{
			// Ignore this field, it should have already generated an error
			$$ = $1;
			break;
		}

		bool field_added = $1->add_field($3);
		if(!field_added)
		{
			if($3->as_molecular())
			{
				dcerror("Cannot add molecular '" + $3->name() + "' to a molecular field.");
			}
			else if(!$1->has_matching_keywords(*$3))
			{
				dcerror("Mismatched keywords in molecular between " +
					$1->nth_field(0)->name() + " and " + $3->name() + ".");
			}
			else
			{
				dcerror("Unkown error adding field " + $3->name() + " to molecular '"
				             + $1->name() + "'.");
			}
		}

		$$ = $1;
	}

defined_field
	: IDENTIFIER
	{
		if(!current_class)
		{
			dcerror("Field '" + $1 + "' not defined in current class.");
			$$ = nullptr;
			break;
		}

		Field *field = current_class->field_by_name($1);
		if(field == nullptr)
		{
			dcerror("Field '" + $1 + "' not defined in current class.");
			$$ = nullptr;
			break;
		}

		$$ = field;
	}
	;

builtin_array_type
	: array_type_token
	{
		if($1 == kTypeString)
		{
			if(default_string == nullptr)
			{
				default_string = new Array(new Numeric(kTypeChar));
				default_string->set_alias("string");
			}

			$$ = default_string;
		}
		else if($1 == kTypeBlob)
		{
			if(default_blob == nullptr)
			{
				default_blob = new Array(new Numeric(kTypeUint8));
				default_blob->set_alias("blob");
			}

			$$ = default_blob;
		}
		else
		{
			dcerror("Found builtin Array not handled by parser.");
			$$ = nullptr;
		}
	}
	| array_type_token '(' array_range ')'
	{
		if($1 == kTypeString)
		{
			Array* arr = new Array(new Numeric(kTypeChar), $3);
			arr->set_alias("string");
			$$ = arr;
		}
		else if($1 == kTypeBlob)
		{
			Array* arr = new Array(new Numeric(kTypeUint8), $3);
			arr->set_alias("blob");
			$$ = arr;
		}
		else
		{
			dcerror("Found builtin Array not handled by parser.");
			$$ = nullptr;
		}
	}
	;

numeric_type
	: numeric_token_only
	| numeric_with_modulus
	| numeric_with_divisor
	| numeric_with_range
	;

numeric_token_only
	: numeric_type_token { $$ = new Numeric($1); }
	;

numeric_with_range
	: numeric_token_only '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	| numeric_with_modulus '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	| numeric_with_divisor '(' numeric_range ')'
	{
		if(!$1->set_range($3))
		{
			dcerror("Invalid range for type.");
		}

		$$ = $1;
	}
	;

numeric_with_modulus
	: numeric_token_only '%' number
	{
		if(!$1->set_modulus($3))
		{
			dcerror("Invalid modulus for type.");
		}

		$$ = $1;
	}
	;

numeric_with_divisor
	: numeric_token_only '/' small_unsigned_integer
	{
		if(!$1->set_divisor($3))
		{
			dcerror("Invalid divisor for type.");
		}
	}
	| numeric_with_modulus '/' small_unsigned_integer
	{
		if(!$1->set_divisor($3))
		{
			dcerror("Invalid divisor for type.");
		}
	}
	;

method
	: '(' ')'
	{
		$$ = new Method();
	}
	| method_body ')'
	{
		$$ = $1;
	}
	;

method_body
	: '(' parameter
	{
		Method* fn = new Method();
		bool param_added = fn->add_param(unique_ptr<Parameter>($2));
		if(!param_added)
		{
			dcerror("Unknown error adding parameter to method.");
		}
		$$ = fn;
	}
	| method_body ',' parameter
	{
		bool param_added = $1->add_param(unique_ptr<Parameter>($3));
		if(!param_added)
		{
			dcerror("Cannot add parameter '" + $3->name()
			             + "', a parameter with that name is already used in this method.");
		}
		$$ = $1;
	}
	;

parameter
	: param_with_name
	| param_with_name_as_array
	| param_with_name_and_default
	| nonmethod_type
	{
		$$ = new Parameter($1);
	}
	| nonmethod_type '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1,0));
	}
	  type_value
	{
		Parameter* param = new Parameter($1);
		if(!type_stack.empty()) depth_error(0, "type");
		param->set_default_value($4);
		$$ = param;
	}

param_with_name
	: nonmethod_type_no_array IDENTIFIER
	{
		$$ = new Parameter($1, $2);
	}
	;

param_with_name_as_array
	: param_with_name '[' array_range ']'
	{
		$1->set_type(new Array($1->type(), $3));
		$$ = $1;
	}
	| param_with_name_as_array '[' array_range ']'
	{
		$1->set_type(new Array($1->type(), $3));
		$$ = $1;
	}
	;

param_with_name_and_default
	: param_with_name '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "parameter '" + $1->name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	| param_with_name_as_array '='
	{
		current_depth = 0;
		type_stack.push(TypeAndDepth($1->type(), 0));
	}
	  type_value
	{
		if(!type_stack.empty()) depth_error(0, "parameter '" + $1->name() + "'");
		$1->set_default_value($4);
		$$ = $1;
	}
	;

numeric_range
	: empty { $$ = NumericRange(); }
	| char_or_number { $$ = NumericRange($1, $1); }
	| char_or_number '-' char_or_number { $$ = NumericRange($1, $3); }
	;

array_range
	: empty { $$ = NumericRange(); }
	| char_or_uint { $$ = NumericRange($1, $1); }
	| char_or_uint '-' char_or_uint { $$ = NumericRange($1, $3); }
	;

char_or_uint
	: CHAR
	{
		if($1.length() != 1)
		{
			dcerror("Single character required.");
			$$ = 0;
		}
		else
		{
			$$ = (unsigned char)$1[0];
		}
	}
	| small_unsigned_integer
	;

small_unsigned_integer
	: UNSIGNED_INTEGER
	{
		unsigned int num = (unsigned int)$1;
		if(num != $1)
		{
			dcerror("Number out of range.");
			$$ = 1;
		}
		$$ = num;
	}
	;

number
	: UNSIGNED_INTEGER { $$ = (double)$1; }
	| signed_integer { $$ = (double)$1; }
	| REAL
	;

char_or_number
	: CHAR
	{
		if($1.length() != 1) {
			dcerror("Single character required.");
			$$ = 0;
		} else {
			$$ = (double)(unsigned char)$1[0];
		}
	}
	| number
	;

type_value
	: signed_integer
	{
		if(!check_depth()) depth_error("signed integer");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype, $1);
	}
	| UNSIGNED_INTEGER
	{
		if(!check_depth()) depth_error("unsigned integer");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype, $1);
	}
	| REAL
	{
		if(!check_depth()) depth_error("floating point");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove numeric type from stack

		$$ = number_value(dtype, $1);
	}
	| CHAR
	{
		if(!check_depth()) depth_error("char");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove char type from stack

		if(dtype->subtype() == kTypeChar) {
			dcerror("Cannot use char value for non-string type '"
			             + format_subtype(dtype->subtype()) + "'.");
		}

		Value value(dtype);
		value.m_char = $1;
		$$ = value;
	}
	| STRING
	{
		if(!check_depth()) depth_error("string");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove string type from stack

		if(dtype->subtype() == kTypeString || dtype->subtype() == kTypeBlob) {
			if($1.length() != dtype->fixed_size()) {
				dcerror("Value for fixed-length string has incorrect length.");
			}

			Value value(dtype);
			value.m_string = $1;
			$$ = value;
		}
		else {
			dcerror("Cannot use string value for non-string type '"
			             + format_subtype(dtype->subtype()) + "'.");
			$$ = Value();
		}
	}
	| HEX_STRING
	{
		if(!check_depth()) depth_error("hex-string");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = Value();
			break;
		}
		type_stack.pop(); // Remove type from stack

		if(dtype->subtype() == kTypeBlob) {
			if($1.length() != dtype->fixed_size()) {
				dcerror("Value for fixed-length blob has incorrect length.");
			}

			Value value(dtype)
			value.m_blob = as_buffer($1);
			$$ = value;
		} else {
			dcerror("Cannot use hex value for non-blob type '"
			             + format_subtype(dtype->subtype()) + "'.");
			$$ = as_buffer($1);
		}
	}
	| array_value
	| struct_value
	;

method_value
	: '('
	{
		if(!check_depth()) depth_error("method");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_method()) {
			current_depth++;
			const Method* method = dtype->as_method();

			size_t num_params = method->num_params();
			for(unsigned int i = 1; i <= num_params; ++i) {
				// Reverse iteration
				const Parameter* param = method->nth_param(num_params-i);
				// Add parameter types to stack such that the first is on top
				type_stack.push(TypeAndDepth(param->type(), current_depth));
			}
		} else {
			dcerror("Cannot use method-value for non-method type '"
			             + format_subtype(dtype->subtype()) + "'.");
		}
	}
	  parameter_values ')'
	{
		if(type_stack.top().type->as_method()) {
			current_depth--;
		}
		type_stack.pop(); // Remove method type from the stack
		$$ = $3;
	}
	;

parameter_values
	: type_value
	| parameter_values ',' type_value
	{
		if($1->type()->subtype() == kTypeNone) {
			// Ignore this argument list, it should have already generated an error
			$$ = Value();
		} else {
			vector<uint8_t> buf = $1;
			pack_value($3, buf);
			$$ = buf;
		}
	}
	;

struct_value
	: '{'
	{
		if(!check_depth()) depth_error("struct");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_struct()) {
			current_depth++;
			const Struct* dstruct = dtype->as_struct();

			size_t num_fields = dstruct->num_fields();
			for(unsigned int i = 1; i <= num_fields; ++i) {
				// Reverse iteration
				const Field* field = dstruct->nth_field(num_fields-i);
				// Add field types to stack such that the first is on top
				type_stack.push(TypeAndDepth(field->type(), current_depth));
			}
		} else {
			dcerror("Cannot use struct-composition for non-struct type '"
			             + format_subtype(dtype->subtype()) + "'.");
		}
	}
	  field_values '}'
	{
		if(type_stack.top().type->as_struct()) {
			current_depth--;
		}
		type_stack.pop(); // Remove method type from the stack
		$$ = $3;
	}
	;

field_values
	: type_value
	| method_value
	| field_values ',' type_value
	{
		vector<uint8_t> buf = $1;
		pack_value($3, buf);
		$$ = buf;
	}
	| field_values ',' method_value
	{
		vector<uint8_t> buf = $1;
		pack_value($3, buf);
		$$ = buf;
	}
	;

array_value
	: '[' ']' // empty array
	{
		if(!check_depth()) depth_error("array");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();;
			break;
		}
		type_stack.pop();
		if(!dtype->as_array()) {
			dcerror("Cannot use array-composition for non-array type '"
			             + format_subtype(dtype->subtype()) + "'.");
			$$ = vector<uint8_t>();;
			break;
		}
		const Array* array = dtype->as_array();

		if(array->array_size() > 0) {
			// For fixed size arrays, an empty array is an error
			dcerror("Fixed-sized array of size "
			             + to_string(array->array_size())
			             + " can't have 0 elements.");
		} else if(array->has_range()) {
			// If we have a range, 0 elements must be valid in the range
			if(0 < array->range().min.uinteger) {
				dcerror("Too few elements in array value, minimum "
				             + to_string(array->range().min.uinteger) + ".");
			}
		}

		// Since a fixed-size array can't have zero elements, this always
		// the default value for a varsize array, which is the length-tag 0.
		$$ = vector<uint8_t>(sizeof(sizetag_t), 0);
	}
	| '['
	{
		if(!check_depth()) depth_error("array");

		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}

		if(dtype->as_array()) {
			const Array* array = dtype->as_array();

			// For arrays we're going to do something pretty hacky:
			//    For every element we had we are going to increment the depth,
			//    and after we finish the element_values production we will compare
			//    the current_depth to the depth of our original symbol to check
			//    if the array size is proper.
			type_stack.push(TypeAndDepth(array->element_type(), current_depth));
		} else {
			dcerror("Cannot use array-composition for non-array type '"
			             + format_subtype(dtype->subtype()) + "'.");
		}
	}
	  element_values ']'
	{
		if(type_stack.top().type->as_array()) {
			uint64_t actual_size = current_depth - type_stack.top().depth;

			const Type* dtype = type_stack.top().type;
			if(dtype == nullptr) {
				// Ignore this field, it should have already generated an error
				$$ = vector<uint8_t>();
				break;
			}

			const Array* array = dtype->as_array();
			if(array->has_range()) {
				if(actual_size > array->range().max.uinteger) {
					dcerror("Too many elements in array value, maximum "
					             + to_string(array->range().max.uinteger) + ".");
				} else if(actual_size < array->range().min.uinteger) {
					dcerror("Too few elements in array value, minimum "
					             + to_string(array->range().min.uinteger) + ".");
				}
			}

			if(array->array_size() == 0) {
				vector<uint8_t> buf = as_buffer(sizetag_t($3.size()));
				pack_value($3, buf);
				$$ = buf;
			} else {
				$$ = $3;
			}
			current_depth = type_stack.top().depth;
		}

		type_stack.pop(); // Remove array type from the stack
	}
	;

element_values
	: array_expansion
	| element_values ','
	{
		// We popped off the only element we added, so we're back to the array
		// Don't increment the depth; the array_expansion will add to
		// the current_depth depending on the number of elements it adds.
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			break;
		}
		const Array* array = dtype->as_array();
		type_stack.push(TypeAndDepth(array->element_type(), current_depth));
	}
	  array_expansion
	{
		// $4 packed onto end of $1
		std::vector<uint8_t> buf = $1;
		pack_value($4, buf);
		$$ = buf;
	}
	;

array_expansion
	: type_value
	{
		current_depth++;
		$$ = $1;
	}
	| signed_integer '*' small_unsigned_integer
	{
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> declared = number_value(dtype->subtype(), $1);
		buf.reserve(declared.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(declared, buf);
		}
		$$ = buf;
	}
	| UNSIGNED_INTEGER '*' small_unsigned_integer
	{
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> declared = number_value(dtype->subtype(), $1);
		buf.reserve(declared.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(declared, buf);
		}
		$$ = buf;
	}
	| REAL '*' small_unsigned_integer
	{
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		vector<uint8_t> buf;
		vector<uint8_t> declared = number_value(dtype->subtype(), $1);
		buf.reserve(declared.size() * $3);
		for(unsigned int i = 0; i < $3; ++i) {
			pack_value(declared, buf);
		}
		$$ = buf;
	}
	| STRING '*' small_unsigned_integer
	{
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		if(dtype->subtype() == kTypeString) {
			if($1.length() != dtype->fixed_size()) {
				dcerror("Value for fixed-length string has incorrect length.");
			}

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		} else if(dtype->subtype() == kTypeVarstring) {
			// Prepend length tag
			vector<uint8_t> buf = as_buffer($1.length());
			vector<uint8_t> declared = as_buffer($1);
			buf.reserve(declared.size() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value(declared, buf);
			}
			$$ = buf;

			// TODO: Check for range limits

		} else {
			dcerror("Cannot use string value for non-string type '"
			             + format_subtype(dtype->subtype()) + "'.");

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		}
	}
	| HEX_STRING '*' small_unsigned_integer
	{
		const Type* dtype = type_stack.top().type;
		if(dtype == nullptr) {
			// Ignore this field, it should have already generated an error
			$$ = vector<uint8_t>();
			break;
		}
		type_stack.pop(); // Pop that array element type
		current_depth += $3; // For arrays, we add 1 to the depth per element

		if(dtype->subtype() == kTypeBlob) {
			if($1.length() != dtype->fixed_size()) {
				dcerror("Value for fixed-length blob has incorrect length.");
			}

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		} else if(dtype->subtype() == kTypeVarblob) {
			// Prepend length tag
			vector<uint8_t> buf = as_buffer($1.length());
			vector<uint8_t> declared = as_buffer($1);
			buf.reserve(declared.size() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value(declared, buf);
			}
			$$ = buf;

			// TODO: Check for range limits

		} else {
			dcerror("Cannot use hex value for non-blob type '"
			             + format_subtype(dtype->subtype()) + "'.");

			vector<uint8_t> buf;
			buf.reserve($1.length() * $3);
			for(unsigned int i = 0; i < $3; ++i) {
				pack_value($1, buf);
			}
			$$ = buf;
		}
	}
	;

signed_integer
	: '+' UNSIGNED_INTEGER { $$ = int64_t($2); }
	| '-' UNSIGNED_INTEGER { $$ = -int64_t($2); }
	;

array_type_token
	: KW_STRING { $$ = kTypeString; }
	| KW_BLOB { $$ = kTypeBlob; }
	;

numeric_type_token
	: KW_CHAR { $$ = kTypeChar; }
	| KW_INT8 { $$ = kTypeInt8; }
	| KW_INT16 { $$ = kTypeInt16; }
	| KW_INT32 { $$ = kTypeInt32; }
	| KW_INT64 { $$ = kTypeInt64; }
	| KW_UINT8 { $$ = kTypeUint8; }
	| KW_UINT16 { $$ = kTypeUint16; }
	| KW_UINT32 { $$ = kTypeUint32; }
	| KW_UINT64 { $$ = kTypeUint64; }
	| KW_FLOAT32 { $$ = kTypeFloat32; }
	| KW_FLOAT64 { $$ = kTypeFloat64; }
	;

keyword_list
	: empty
	{
		$$ = vector<string>();
	}
	| keyword_list IDENTIFIER
	{
		if(!parsed_module->has_keyword($2))
		{
			dcerror("Keyword '" + $2 + "' has not been declared.");
			break;
		}

		$1.push_back($2);
		$$ = $1;
	}
	;

empty
	:
	;

%% /* Start helper function section */
namespace bamboo
{ // open namespace bamboo


Module *read_dcfile(istream& in, const string& filename) {
    Module *m = new Module();
    bool ok = parse_dcfile(m, in, filename);
    if(ok) {
        return m;
    }

    return nullptr;
}
Module *read_dcfile(const string& filename) {
    Module *m = new Module();
    bool ok = parse_dcfile(m, filename);
    if(ok) {
        return m;
    }

    return nullptr;
}
bool parse_dcfile(Module *m, istream& in, const string& filename) {
    dcparser_init_file(in, filename, *m);
    dcparse();
    dcparser_cleanup();
    return (dc_errors() == 0);
}
bool parse_dcfile(Module *m, const string& filename) {
    ifstream in;
    in.open(filename.c_str());
    if(!in) {
        cerr << "Cannot open " << filename << " for reading.\n";
        return false;
    }
    return parse_dcfile(m, in, filename);
}
Value parse_dcvalue(const Type *dtype, const string& formatted, bool& err) {
    istringstream strm(formatted);
    return parse_dcvalue(dtype, strm, err);
}
Value parse_dcvalue(const Type *dtype, istream& in, bool& err) {
    vector<uint8_t> packed = parse_packed(dtype, in, err);
    if(err) { return Value(dtype); }
    else { return Value(dtype, packed); }
}
vector<uint8_t> parse_packed(const Type *dtype, const string& formatted, bool& err) {
    istringstream strm(formatted);
    return parse_packed(dtype, strm, err);
}
vector<uint8_t> parse_packed(const Type *dtype, istream& in, bool& err) {
    vector<uint8_t> value;
    try {
        dcparser_init_value(in, "parse_value()", dtype, value);
        dcparse();
        dcparser_cleanup();
    } catch(const exception& e) {
        err = true;
        return vector<uint8_t>();
    }

    if(dc_errors() > 0) {
        err = true;
        return vector<uint8_t>();
    }

    err = false;
    return value;
}


bool check_depth()
{
	return (!type_stack.empty() && current_depth == type_stack.top().depth);
}

void depth_error(string what)
{
	if(type_stack.empty() || current_depth < type_stack.top().depth) {
		dcerror("Too many nested values while parsing value for " + what + ".");
	} else {
		dcerror("Too few nested values while parsing value for " + what + ".");
	}
}

void depth_error(int depth, string what)
{
	if(current_depth > depth) {
		dcerror("Too few nested values before this " + what + " value.");
	} else {
		dcerror("Too many nested values before this " + what + " value.");
	}
}

Value number_value(const Type *type, double &number)
{
	switch(type->subtype()) {
	case kTypeFloat32:
		if(isinf(float(number))) { dcerror("Value is out of range for type 'float32'."); }
		{
			Value value(type);
			value.m_float32 = number;
			return value;
		}
	case kTypeFloat64:
		{
			Value value(type);
			value.m_float64 = number;
			return value;
		}
	case kTypeInt8:
	case kTypeInt16:
	case kTypeInt32:
	case kTypeInt64:
	case kTypeChar:
	case kTypeUint8:
	case kTypeUint16:
	case kTypeUint32:
	case kTypeUint64:
		dcerror("Cannot use floating-point value for integer datatype.");
		return Value();
	default:
		dcerror("Cannot use floating-point value for non-numeric datatype.");
		return Value();
	}
}

Value number_value(const Type *type, int64_t &number)
{
	switch(type->subtype()) {
	case kTypeInt8:
		if(INT8_MIN > number || number > INT8_MAX) {
			dcerror("Signed integer out of range for type 'int8'.");
		} else {
			Value value(type);
			value.m_int8 = number;
			return value;
		}
	case kTypeInt16:
		if(INT16_MIN > number || number > INT16_MAX) {
			dcerror("Signed integer out of range for type 'int16'.");
		} else {
			Value value(type);
			value.m_int16 = number;
			return value;
		}
	case kTypeInt32:
		if(INT32_MIN > number || number > INT32_MAX) {
			dcerror("Signed integer out of range for type 'int32'.");
		} else {
			Value value(type);
			value.m_int32 = number;
			return value;
		}
	case kTypeInt64:
		{
			Value value(type);
			value.m_int64 = number;
			return value;
		}
	case kTypeChar:
	case kTypeUint8:
	case kTypeUint16:
	case kTypeUint32:
	case kTypeUint64:
		if(number < 0) {
			dcerror("Can't use negative value for unsigned integer datatype.");
		} else {
			uint64_t value = number;
			return number_value(type, value);
		}
	case kTypeFloat32:
	case kTypeFloat64:
		{
			double value = number;
			return number_value(type, value);
		}
	default:
		dcerror("Cannot use signed integer value for non-numeric datatype.");
		return Value();
	}
}

Value number_value(const Type *type, uint64_t &number)
{
	switch(type->subtype()) {
	case kTypeChar:
		if(number > UINT8_MAX) {
			dcerror("Unsigned integer out of range for type 'char'.");
		} else {
			Value value(type);
			value.m_char = number;
			return value;
		}
	case kTypeUint8:
		if(number > UINT8_MAX) {
			dcerror("Unsigned integer out of range for type 'uint8'.");
		} else {
			Value value(type);
			value.m_uint8 = number;
			return value;
		}
	case kTypeUint16:
		if(number > UINT16_MAX) {
			dcerror("Unsigned integer out of range for type 'uint16'.");
		} else {
			Value value(type);
			value.m_uint16 = number;
			return value;
		}
	case kTypeUint32:
		if(number > UINT32_MAX) {
			dcerror("Unsigned integer out of range for type 'uint32'.");
		} else {
			Value value(type);
			value.m_uint32 = number;
			return value;
		}
	case kTypeUint64:
		{
			Value value(type);
			value.m_uint64 = number;
			return value;
		}
	case kTypeInt8:
	case kTypeInt16:
	case kTypeInt32:
	case kTypeInt64:
		if(number > INT64_MAX) {
			dcerror("Unsigned integer out of range for signed integer datatype.");
		} else {
			int64_t value = number;
			return number_value(type, value);
		}
	case kTypeFloat32:
	case kTypeFloat64:
		{
			double value = number;
			return number_value(type, value);
		}
	default:
		dcerror("Cannot use unsigned integer value for non-numeric datatype.");
		return Value();
	}
}


} // close namespace bamboo
